<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CSV.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>CSV.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Reading"><span>Reading</span></a></li><li><a class="tocitem" href="#input"><span><code>input</code></span></a></li><li><a class="tocitem" href="#header"><span><code>header</code></span></a></li><li><a class="tocitem" href="#normalizenames"><span><code>normalizenames</code></span></a></li><li><a class="tocitem" href="#skipto"><span><code>skipto</code></span></a></li><li><a class="tocitem" href="#footerskip"><span><code>footerskip</code></span></a></li><li><a class="tocitem" href="#transpose"><span><code>transpose</code></span></a></li><li><a class="tocitem" href="#comment"><span><code>comment</code></span></a></li><li><a class="tocitem" href="#ignoreemptyrows"><span><code>ignoreemptyrows</code></span></a></li><li><a class="tocitem" href="#select"><span><code>select</code> / <code>drop</code></span></a></li><li><a class="tocitem" href="#limit"><span><code>limit</code></span></a></li><li><a class="tocitem" href="#ntasks"><span><code>ntasks</code></span></a></li><li><a class="tocitem" href="#rows_to_check"><span><code>rows_to_check</code></span></a></li><li><a class="tocitem" href="#missingstring"><span><code>missingstring</code></span></a></li><li><a class="tocitem" href="#delim"><span><code>delim</code></span></a></li><li><a class="tocitem" href="#ignorerepeated"><span><code>ignorerepeated</code></span></a></li><li><a class="tocitem" href="#quoted"><span><code>quoted</code></span></a></li><li><a class="tocitem" href="#quotechar"><span><code>quotechar</code> / <code>openquotechar</code> / <code>closequotechar</code></span></a></li><li><a class="tocitem" href="#escapechar"><span><code>escapechar</code></span></a></li><li><a class="tocitem" href="#dateformat"><span><code>dateformat</code></span></a></li><li><a class="tocitem" href="#decimal"><span><code>decimal</code></span></a></li><li><a class="tocitem" href="#truestrings"><span><code>truestrings</code> / <code>falsestrings</code></span></a></li><li><a class="tocitem" href="#types"><span><code>types</code></span></a></li><li><a class="tocitem" href="#typemap"><span><code>typemap</code></span></a></li><li><a class="tocitem" href="#pool"><span><code>pool</code></span></a></li><li><a class="tocitem" href="#downcast"><span><code>downcast</code></span></a></li><li><a class="tocitem" href="#stringtype"><span><code>stringtype</code></span></a></li><li><a class="tocitem" href="#strict"><span><code>strict</code> / <code>silencewarnings</code> / <code>maxwarnings</code></span></a></li><li><a class="tocitem" href="#debug"><span><code>debug</code></span></a></li><li class="toplevel"><a class="tocitem" href="#Common-terms"><span>Common terms</span></a></li><li class="toplevel"><a class="tocitem" href="#Writing"><span>Writing</span></a></li></ul></li><li><a class="tocitem" href="examples/">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaData/CSV.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CSV.jl-Documentation"><a class="docs-heading-anchor" href="#CSV.jl-Documentation">CSV.jl Documentation</a><a id="CSV.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#CSV.jl-Documentation" title="Permalink"></a></h1><p>GitHub Repo: https://github.com/JuliaData/CSV.jl</p><ul><ul><li><a href="examples/#API-Reference">API Reference</a></li><li><a href="examples/#Utilities">Utilities</a></li><li><a href="examples/#Examples">Examples</a></li></ul><li><a href="#CSV.jl-Documentation">CSV.jl Documentation</a></li><li><a href="#Reading">Reading</a></li><ul><li><a href="#input"><code>input</code></a></li><li><a href="#header"><code>header</code></a></li><li><a href="#normalizenames"><code>normalizenames</code></a></li><li><a href="#skipto"><code>skipto</code></a></li><li><a href="#footerskip"><code>footerskip</code></a></li><li><a href="#transpose"><code>transpose</code></a></li><li><a href="#comment"><code>comment</code></a></li><li><a href="#ignoreemptyrows"><code>ignoreemptyrows</code></a></li><li><a href="#select"><code>select</code> / <code>drop</code></a></li><li><a href="#limit"><code>limit</code></a></li><li><a href="#ntasks"><code>ntasks</code></a></li><li><a href="#rows_to_check"><code>rows_to_check</code></a></li><li><a href="#missingstring"><code>missingstring</code></a></li><li><a href="#delim"><code>delim</code></a></li><li><a href="#ignorerepeated"><code>ignorerepeated</code></a></li><li><a href="#quoted"><code>quoted</code></a></li><li><a href="#quotechar"><code>quotechar</code> / <code>openquotechar</code> / <code>closequotechar</code></a></li><li><a href="#escapechar"><code>escapechar</code></a></li><li><a href="#dateformat"><code>dateformat</code></a></li><li><a href="#decimal"><code>decimal</code></a></li><li><a href="#truestrings"><code>truestrings</code> / <code>falsestrings</code></a></li><li><a href="#types"><code>types</code></a></li><li><a href="#typemap"><code>typemap</code></a></li><li><a href="#pool"><code>pool</code></a></li><li><a href="#downcast"><code>downcast</code></a></li><li><a href="#stringtype"><code>stringtype</code></a></li><li><a href="#strict"><code>strict</code> / <code>silencewarnings</code> / <code>maxwarnings</code></a></li><li><a href="#debug"><code>debug</code></a></li></ul><li><a href="#Common-terms">Common terms</a></li><li><a href="#Writing">Writing</a></li></ul><p>Welcome to CSV.jl! A pure-Julia package for handling delimited text data, be it comma-delimited (csv), tab-delimited (tsv), or otherwise.</p><p>To start out, let&#39;s discuss the high-level functionality provided by the package, which hopefully will help direct you to more specific documentation for your use-case:</p><ul><li><a href="examples/#CSV.File"><code>CSV.File</code></a>: the most commonly used function for ingesting delimited data; will read an entire file, detecting number of columns and rows, along with the type of data for each column. Returns a <code>CSV.File</code> object, which is like a lightweight table/DataFrame. Assuming <code>file</code> is a variable of a <code>CSV.File</code> object, individual columns can be accessed like <code>file.col1</code>, <code>file[:col1]</code>, or <code>file[&quot;col&quot;]</code>. You can see parsed column names via <code>file.names</code>. A <code>CSV.File</code> can also be iterated, where a <code>CSV.Row</code> is produced on each iteration, which allows access to each value in the row via <code>row.col1</code>, <code>row[:col1]</code>, or <code>row[1]</code>. You can also index a <code>CSV.File</code> directly, like <code>file[1]</code> to return the entire <code>CSV.Row</code> at the provided index/row number. Multiple threads will be used while parsing the input data if the input is large enough, and full return column buffers to hold the parsed data will be allocated. <code>CSV.File</code> satisfies the <a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a> &quot;source&quot; interface, and so can be passed to valid sink functions like <code>DataFrame</code>, <code>SQLite.load!</code>, <code>Arrow.write</code>, etc. Supports a number of keyword arguments to control parsing, column type, and other file metadata options.</li><li><a href="examples/#CSV.read"><code>CSV.read</code></a>: a convenience function identical to <code>CSV.File</code>, but used when a <code>CSV.File</code> will be passed direclty to a sink function, like a <code>DataFrame</code>. In some cases, sinks may make copies of incoming data for their own safety; by calling <code>CSV.read(file, DataFrame)</code>, no copies of the parsed <code>CSV.File</code> will be made, and the <code>DataFrame</code> will take direct ownership of the <code>CSV.File</code>&#39;s columns, which is more efficient than doing <code>CSV.File(file) |&gt; DataFrame</code> which will result in an extra copy of each column being made. Keyword arguments are identical to <code>CSV.File</code>. Any valid Tables.jl sink function/table type can be passed as the 2nd argument.</li><li><a href="examples/#CSV.Rows"><code>CSV.Rows</code></a>: an alternative approach for consuming delimited data, where the input is only consumed one row at a time, which allows &quot;streaming&quot; the data with a lower memory footrpint than <code>CSV.File</code>. Supports many of the same options as <code>CSV.File</code>, except column type handling is a little different. By default, every column type will be essentially <code>Union{Missing, String}</code>, i.e. no automatic type detection is done, but column types can be provided manually. Multithreading is not used while parsing. After constructing a <code>CSV.Rows</code> object, rows can be &quot;streamed&quot; by iterating, where each iteration produces a <code>CSV.Row2</code> object, which operates similar to <code>CSV.File</code>&#39;s <code>CSV.Row</code> type where individual row values can be accessed via <code>row.col1</code>, <code>row[:col1]</code>, or <code>row[1]</code>. If each row is processed individually, additional memory can be saved by passing <code>reusebuffer=true</code>, which means a single buffer will be allocated to hold the values of only the currently iterated row. <code>CSV.Rows</code> also supports the Tables.jl interface and can also be passed to valid sink functions.</li><li><a href="examples/#CSV.Chunks"><code>CSV.Chunks</code></a>: similar to <code>CSV.File</code>, but allows passing a <code>ntasks::Integer</code> keyword argument which will cause the input file to be &quot;chunked&quot; up into <code>ntasks</code> number of chunks. After constructing a <code>CSV.Chunks</code> object, each iteration of the object will return a <code>CSV.File</code> of the next parsed chunk. Useful for processing extremely large files in &quot;chunks&quot;. Because each iterated element is a valid Tables.jl &quot;source&quot;, <code>CSV.Chunks</code> satisfies the <code>Tables.partitions</code> interface, so sinks that can process input partitions can operate by passing <code>CSV.Chunks</code> as the &quot;source&quot;.</li><li><a href="#CSV.write"><code>CSV.write</code></a>: A valid Tables.jl &quot;sink&quot; function for writing any valid input table out in a delimited text format. Supports many options for controlling the output like delimiter, quote characters, etc. Writes data to an internal buffer, which is flushed out when full, buffer size is configurable. Also supports writing out partitioned inputs as separate output files, one file per input partition. To write out a <code>DataFrame</code>, for example, it&#39;s simply <code>CSV.write(&quot;data.csv&quot;, df)</code>, or to write out a matrix, it&#39;s <code>using Tables; CSV.write(&quot;data.csv&quot;, Tables.table(mat))</code></li><li><a href="#CSV.RowWriter"><code>CSV.RowWriter</code></a>: An alternative way to produce csv output; takes any valid Tables.jl input, and on each iteration, produces a single csv-formatted string from the input table&#39;s row.</li></ul><p>That&#39;s quite a bit! Let&#39;s boil down a TL;DR:</p><ul><li>Just want to read a delimited file and do basic stuff with data? Use <code>CSV.File(file)</code> or <code>CSV.read(file, DataFrame)</code></li><li>Don&#39;t need the data as a whole or want to stream through a large file row-by-row? Use <code>CSV.Rows</code>.</li><li>Want to process a large file in &quot;batches&quot;/chunks? Use <code>CSV.Chunks</code>.</li><li>Need to produce a csv? Use <code>CSV.write</code>.</li><li>Want to iterate an input table and produce a single csv string per row? <code>CSV.RowWriter</code>.</li></ul><p>For the rest of the manual, we&#39;re going to have two big sections, <em>Reading</em> and <em>Writing</em> where we&#39;ll walk through the various options to <code>CSV.File</code>/<code>CSV.read</code>/<code>CSV.Rows</code>/<code>CSV.Chunks</code> and <code>CSV.write</code>/<code>CSV.RowWriter</code>.</p><h1 id="Reading"><a class="docs-heading-anchor" href="#Reading">Reading</a><a id="Reading-1"></a><a class="docs-heading-anchor-permalink" href="#Reading" title="Permalink"></a></h1><p>The format for this section will go through the various inputs/options supported by <code>CSV.File</code>, with notes about compatibility with the other reading functionality (<code>CSV.Rows</code>, <code>CSV.Chunks</code>, etc.).</p><h2 id="input"><a class="docs-heading-anchor" href="#input"><code>input</code></a><a id="input-1"></a><a class="docs-heading-anchor-permalink" href="#input" title="Permalink"></a></h2><p>A required argument for reading. Input data should be ASCII or UTF-8 encoded text; for other text encodings, use the <a href="https://github.com/JuliaStrings/StringEncodings.jl">StringEncodings.jl</a> package to convert to UTF-8.</p><p>Any delimited input is ultimately converted to a byte buffer (<code>Vector{UInt8}</code>) for parsing/processing, so with that in mind, let&#39;s look at the various supported input types:</p><ul><li>File name as a <code>String</code> or <a href="https://juliahub.com/docs/FilePaths/PrU4O/0.8.0/"><code>FilePath</code></a>; parsing will call <code>Mmap.mmap(string(file))</code> to get a byte buffer to the file data. For gzip compressed inputs, like <code>file.gz</code>, the <a href="https://juliahub.com/docs/CodecZlib/1TI30/0.7.0/">CodecZlib.jl</a> package will be used to decompress the data to a temporary file first, then mmapped to a byte buffer. Decompression can also be done in memory by passing <code>buffer_in_memory=true</code>. Note that only gzip-compressed data is automatically decompressed; for other forms of compressed data, seek out the appropriate package to decompress and pass an IO or <code>Vector{UInt8}</code> of decompressed data as input.</li><li><code>AbstractVector{UInt8}</code>: if you already have a byte buffer from wherever, you can just pass it in directly. If you have a csv-formatted string, you can pass it like <code>CSV.File(IOBuffer(str))</code></li><li><code>IO</code> or <code>Cmd</code>: you can pass an <code>IO</code> or <code>Cmd</code> directly, which will be consumed into a temporary file, then mmapped as a byte vector; to avoid a temp file and instead buffer data in memory, pass <code>buffer_in_memory=true</code>.</li><li>For files from the web, you can call <code>HTTP.get(url).body</code> to request the file, then access the data as a <code>Vector{UInt8}</code> from the <code>body</code> field, which can be passed directly for parsing. For Julia 1.6+, you can also use the <code>Downloads</code> stdlib, like <code>Downloads.download(url)</code> which can be passed to parsing</li></ul><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><ul><li><a href="examples/#stringencodings">StringEncodings.jl example</a></li><li><a href="examples/#gzipped_input">Gzip input</a></li><li><a href="examples/#csv_string">Delimited data in a string</a></li><li><a href="examples/#http">Data from the web</a></li><li><a href="examples/#zip_example">Data in zip archive</a></li></ul><h2 id="header"><a class="docs-heading-anchor" href="#header"><code>header</code></a><a id="header-1"></a><a class="docs-heading-anchor-permalink" href="#header" title="Permalink"></a></h2><p>The <code>header</code> keyword argument controls how column names are treated when processing files. By default, it is assumed that the column names are the first row/line of the input, i.e. <code>header=1</code>. Alternative valid aguments for <code>header</code> include:</p><ul><li><code>Integer</code>, e.g. <code>header=2</code>: provide the row number as an <code>Integer</code> where the column names can be found</li><li><code>Bool</code>, e.g. <code>header=false</code>: no column names exist in the data; column names will be auto-generated depending on the # of columns, like <code>Column1</code>, <code>Column2</code>, etc.</li><li><code>Vector{String}</code> or <code>Vector{Symbol}</code>: manually provide column names as strings or symbols; should match the # of columns in the data. A copy of the <code>Vector</code> will be made and converted to <code>Vector{Symbol}</code></li><li><code>AbstractVector{&lt;:Integer}</code>: in rare cases, there may be multi-row headers; by passing a collection of row numbers, each row will be parsed and the values for each row will be concatenated to form the final column names</li></ul><h3 id="Examples-2"><a class="docs-heading-anchor" href="#Examples-2">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-2" title="Permalink"></a></h3><ul><li><a href="examples/#second_row_header">Column names on second row</a></li><li><a href="examples/#no_header">No column names in the data</a></li><li><a href="examples/#manual_header">Manually provide column names</a></li><li><a href="examples/#multi_row_header">Multi-row column names</a></li></ul><h2 id="normalizenames"><a class="docs-heading-anchor" href="#normalizenames"><code>normalizenames</code></a><a id="normalizenames-1"></a><a class="docs-heading-anchor-permalink" href="#normalizenames" title="Permalink"></a></h2><p>Controls whether column names will be &quot;normalized&quot; to valid Julia identifiers. By default, this is <code>false</code>. If <code>normalizenames=true</code>, then column names with spaces, or that start with numbers, will be adjusted with underscores to become valid Julia identifiers. This is useful when you want to access columns via dot-access or <code>getproperty</code>, like <code>file.col1</code>. The identifier that comes after the <code>.</code> must be valid, so spaces or identifiers starting with numbers aren&#39;t allowed.</p><h3 id="Examples-3"><a class="docs-heading-anchor" href="#Examples-3">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-3" title="Permalink"></a></h3><ul><li><a href="examples/#normalize_header">Normalizing column names</a></li></ul><h2 id="skipto"><a class="docs-heading-anchor" href="#skipto"><code>skipto</code></a><a id="skipto-1"></a><a class="docs-heading-anchor-permalink" href="#skipto" title="Permalink"></a></h2><p>An <code>Integer</code> can be provided that specifies the row number where the data is located. By default, the row immediately following the header row is assumed to be the start of data. If <code>header=false</code>, or column names are provided manually as <code>Vector{String}</code> or <code>Vector{Symbol}</code>, the data is assumed to start on row 1, i.e. <code>skipto=1</code>.</p><h3 id="Examples-4"><a class="docs-heading-anchor" href="#Examples-4">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-4" title="Permalink"></a></h3><ul><li><a href="examples/#skipto_example">Skip to specific row where data starts</a></li></ul><h2 id="footerskip"><a class="docs-heading-anchor" href="#footerskip"><code>footerskip</code></a><a id="footerskip-1"></a><a class="docs-heading-anchor-permalink" href="#footerskip" title="Permalink"></a></h2><p>An <code>Integer</code> argument specifying the number of rows to ignore at the end of a file. This works by the parser starting at the end of the file and parsing in reverse until <code>footerskip</code> # of rows have been parsed, then parsing the entire file, stopping at the newly adjusted &quot;end of file&quot;.</p><h3 id="Examples-5"><a class="docs-heading-anchor" href="#Examples-5">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-5" title="Permalink"></a></h3><ul><li><a href="examples/#footerskip_example">Skipping trailing useless rows</a></li></ul><h2 id="transpose"><a class="docs-heading-anchor" href="#transpose"><code>transpose</code></a><a id="transpose-1"></a><a class="docs-heading-anchor-permalink" href="#transpose" title="Permalink"></a></h2><p>If <code>transpose=true</code> is passed, data will be read &quot;transposed&quot;, so each row will be parsed as a column, and each column in the data will be returned as a row. Useful when data is extremely wide (many columns), but you want to process it in a &quot;long&quot; format (many rows). Note that multithreaded parsing is not supported when parsing is transposed.</p><h3 id="Examples-6"><a class="docs-heading-anchor" href="#Examples-6">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-6" title="Permalink"></a></h3><ul><li><a href="examples/#transpose_example">Reading transposed data</a></li></ul><h2 id="comment"><a class="docs-heading-anchor" href="#comment"><code>comment</code></a><a id="comment-1"></a><a class="docs-heading-anchor-permalink" href="#comment" title="Permalink"></a></h2><p>A <code>String</code> argument that, when encountered at the start of a row while parsing, will cause the row to be skipped. When providing <code>header</code>, <code>skipto</code>, or <code>footerskip</code> arguments, it should be noted that commented rows, while ignored, still count as &quot;rows&quot; when skipping to a specific row. In this way, you can visually identify, for example, that column names are on row 6, and pass <code>header=6</code>, even if row 5 is a commented row and will be ignored.</p><h3 id="Examples-7"><a class="docs-heading-anchor" href="#Examples-7">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-7" title="Permalink"></a></h3><ul><li><a href="examples/#comment_example">Ignoring commented rows</a></li></ul><h2 id="ignoreemptyrows"><a class="docs-heading-anchor" href="#ignoreemptyrows"><code>ignoreemptyrows</code></a><a id="ignoreemptyrows-1"></a><a class="docs-heading-anchor-permalink" href="#ignoreemptyrows" title="Permalink"></a></h2><p>This argument specifies whether &quot;empty rows&quot;, where consecutive <a href="#newlines">newlines</a> are parsed, should be ignored or not. By default, they are. If <code>ignoreemptyrows=false</code>, then for an empty row, all existing columns will have <code>missing</code> assigned to their value for that row. Similar to commented rows, empty rows also still count as &quot;rows&quot; when any of the <code>header</code>, <code>skipto</code>, or <code>footerskip</code> arguments are provided.</p><h3 id="Examples-8"><a class="docs-heading-anchor" href="#Examples-8">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-8" title="Permalink"></a></h3><ul><li><a href="examples/#ignoreemptyrows_example">Ignoring empty rows</a></li></ul><h2 id="select"><a class="docs-heading-anchor" href="#select"><code>select</code> / <code>drop</code></a><a id="select-1"></a><a class="docs-heading-anchor-permalink" href="#select" title="Permalink"></a></h2><p>Arguments that control which columns from the input data will actually be parsed and available after processing. <code>select</code> controls which columns <em>will</em> be accessible after parsing while <code>drop</code> controls which columns to <em>ignore</em>. Either argument can be provided as a vector of <code>Integer</code>, <code>String</code>, or <code>Symbol</code>, specifing the column numbers or names to include/exclude. A vector of <code>Bool</code> matching the number of columns in the input data can also be provided, where each element specifies whether the corresponding column should be included/excluded. Finally, these arguments can also be given as boolean functions, of the form <code>(i, name) -&gt; Bool</code>, where each column number and name will be given as arguments and the result of the function will determine if the column will be included/excluded.</p><h3 id="Examples-9"><a class="docs-heading-anchor" href="#Examples-9">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-9" title="Permalink"></a></h3><ul><li><a href="examples/#select_example">Including/excluding columns</a></li></ul><h2 id="limit"><a class="docs-heading-anchor" href="#limit"><code>limit</code></a><a id="limit-1"></a><a class="docs-heading-anchor-permalink" href="#limit" title="Permalink"></a></h2><p>An <code>Integer</code> argument to specify the number of rows that should be read from the data. Can be used in conjunction with <a href="#skipto"><code>skipto</code></a> to read contiguous chunks of a file. Note that with multithreaded parsing (when the data is deemed large enough), it can be difficult for parsing to determine the exact # of rows to limit to, so it may or may not return exactly <code>limit</code> number of rows. To ensure an exact limit on larger files, also pass <code>ntasks=1</code> to force single-threaded parsing.</p><h3 id="Examples-10"><a class="docs-heading-anchor" href="#Examples-10">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-10" title="Permalink"></a></h3><ul><li><a href="examples/#limit_example">Limiting number of rows from data</a></li></ul><h2 id="ntasks"><a class="docs-heading-anchor" href="#ntasks"><code>ntasks</code></a><a id="ntasks-1"></a><a class="docs-heading-anchor-permalink" href="#ntasks" title="Permalink"></a></h2><p>NOTE: not applicable to <code>CSV.Rows</code></p><p>For large enough data inputs, <code>ntasks</code> controls the number of multithreaded tasks used to concurrently parse the data. By default, it uses <code>Threads.nthreads()</code>, which is the number of threads the julia process was started with, either via <code>julia -t N</code> or the <code>JULIA_NUM_THREADS</code> environment variable. To avoid multithreaded parsing, even on large files, pass <code>ntasks=1</code>. This argument is only applicable to <code>CSV.File</code>, not <code>CSV.Rows</code>. For <code>CSV.Chunks</code>, it controls the total number of chunk iterations a large file will be split up into for parsing.</p><h2 id="rows_to_check"><a class="docs-heading-anchor" href="#rows_to_check"><code>rows_to_check</code></a><a id="rows_to_check-1"></a><a class="docs-heading-anchor-permalink" href="#rows_to_check" title="Permalink"></a></h2><p>NOTE: not applicable to <code>CSV.Rows</code></p><p>When input data is large enough, parsing will attempt to &quot;chunk&quot; up the data for multithreaded tasks to parse concurrently. To chunk up the data, it is split up into even chunks, then initial parsers attempt to identify the correct start of the first row of that chunk. Once the start of the chunk&#39;s first row is found, each parser will check <code>rows_to_check</code> number of rows to ensure the expected number of columns are present.</p><h2 id="missingstring"><a class="docs-heading-anchor" href="#missingstring"><code>missingstring</code></a><a id="missingstring-1"></a><a class="docs-heading-anchor-permalink" href="#missingstring" title="Permalink"></a></h2><p>Argument to control how <code>missing</code> values are handled while parsing input data. The default is <code>missingstring=&quot;&quot;</code>, which means two consecutive delimiters, like <code>,,</code>, will result in a cell being set as a <code>missing</code> value. Otherwise, you can pass a single string to use as a &quot;sentinel&quot;, like <code>missingstring=&quot;NA&quot;</code>, or a vector of strings, where <em>each</em> will be checked for when parsing, like <code>missingstring=[&quot;NA&quot;, &quot;NAN&quot;, &quot;NULL&quot;]</code>, and if <em>any</em> match, the cell will be set to <code>missing</code>. By passing <code>missingstring=nothing</code>, no <code>missing</code> values will be checked for while parsing.</p><h3 id="Examples-11"><a class="docs-heading-anchor" href="#Examples-11">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-11" title="Permalink"></a></h3><ul><li><a href="examples/#missing_string_example">Specifying custom missing strings</a></li></ul><h2 id="delim"><a class="docs-heading-anchor" href="#delim"><code>delim</code></a><a id="delim-1"></a><a class="docs-heading-anchor-permalink" href="#delim" title="Permalink"></a></h2><p>A <code>Char</code> or <code>String</code> argument that parsing looks for in the data input that separates distinct columns on each row. If no argument is provided (the default), parsing will try to detect the most consistent delimiter on the first 10 rows of the input, falling back to a single comma (<code>,</code>) if no other delimiter can be detected consistently.</p><h3 id="Examples-12"><a class="docs-heading-anchor" href="#Examples-12">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-12" title="Permalink"></a></h3><ul><li><a href="examples/#string_delim">String delimiter</a></li></ul><h2 id="ignorerepeated"><a class="docs-heading-anchor" href="#ignorerepeated"><code>ignorerepeated</code></a><a id="ignorerepeated-1"></a><a class="docs-heading-anchor-permalink" href="#ignorerepeated" title="Permalink"></a></h2><p>A <code>Bool</code> argument, default <code>false</code>, that, if set to <code>true</code>, will cause parsing to ignore any number of consecutive delimiters between columns. This option can often be used to accurately parse fixed-width data inputs, where columns are delimited with a fixed number of delimiters, or a row is fixed-width and columns may have a variable number of delimiters between them based on the length of cell values.</p><h3 id="Examples-13"><a class="docs-heading-anchor" href="#Examples-13">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-13" title="Permalink"></a></h3><ul><li><a href="examples/#ignorerepeated_example">Fixed width files</a></li></ul><h2 id="quoted"><a class="docs-heading-anchor" href="#quoted"><code>quoted</code></a><a id="quoted-1"></a><a class="docs-heading-anchor-permalink" href="#quoted" title="Permalink"></a></h2><p>A <code>Bool</code> argument that controls whether parsing will check for opening/closing quote characters at the start/end of cells. Default <code>true</code>. If you happen to know a file has no quoted cells, it can simplify parsing to pass <code>quoted=false</code>, so parsing avoids treating the <code>quotechar</code> or <code>openquotechar</code>/<code>closequotechar</code> arguments specially.</p><h3 id="Examples-14"><a class="docs-heading-anchor" href="#Examples-14">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-14" title="Permalink"></a></h3><ul><li><a href="examples/#quoted_example">Turning off quoted cell parsing</a></li></ul><h2 id="quotechar"><a class="docs-heading-anchor" href="#quotechar"><code>quotechar</code> / <code>openquotechar</code> / <code>closequotechar</code></a><a id="quotechar-1"></a><a class="docs-heading-anchor-permalink" href="#quotechar" title="Permalink"></a></h2><p>An ASCII <code>Char</code> argument (or arguments if both <code>openquotechar</code> and <code>closequotechar</code> are provided) that parsing uses to handle &quot;quoted&quot; cells. If a cell string value contains the <a href="#delim">delim</a> argument, or a newline, it should start and end with <code>quotechar</code>, or start with <code>openquotechar</code> and end with <code>closequotechar</code> so parsing knows to treat the <code>delim</code> or newline as part of the cell <em>value</em> instead of as significant parsing characters. If the <code>quotechar</code> or <code>closequotechar</code> characters also need to appear in the cell value, they should be properly escaped via the <a href="#escapechar">escapechar</a> argument.</p><h3 id="Examples-15"><a class="docs-heading-anchor" href="#Examples-15">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-15" title="Permalink"></a></h3><ul><li><a href="examples/#quotechar_example">Quoted &amp; escaped fields</a></li></ul><h2 id="escapechar"><a class="docs-heading-anchor" href="#escapechar"><code>escapechar</code></a><a id="escapechar-1"></a><a class="docs-heading-anchor-permalink" href="#escapechar" title="Permalink"></a></h2><p>An ASCII <code>Char</code> argument that parsing uses when parsing quoted cells and the <code>quotechar</code> or <code>closequotechar</code> characters appear in a cell string value. If the <code>escapechar</code> character is encountered inside a quoted cell, it will be &quot;skipped&quot;, and the following character will not be checked for parsing significance, but just treated as another character in the value of the cell. Note the <code>escapechar</code> is <em>not</em> included in the value of the cell, but is ignored completely.</p><h2 id="dateformat"><a class="docs-heading-anchor" href="#dateformat"><code>dateformat</code></a><a id="dateformat-1"></a><a class="docs-heading-anchor-permalink" href="#dateformat" title="Permalink"></a></h2><p>A <code>String</code> or <code>AbstractDict</code> argument that controls how parsing detects datetime values in the data input. As a single <code>String</code> (or <code>DateFormat</code>) argument, the same format will be applied to <em>all</em> columns in the file. For columns without type information provided otherwise, parsing will use the provided format string to check if the cell is parseable and if so, will attempt to parse the entire column as the datetime type (<code>Time</code>, <code>Date</code>, or <code>DateTime</code>). By default, if no <code>dateformat</code> argument is explicitly provided, parsing will try to detect any of <code>Time</code>, <code>Date</code>, or <code>DateTime</code> types following the standard <code>Dates.ISOTimeFormat</code>, <code>Dates.ISODateFormat</code>, or <code>Dates.ISODateTimeFormat</code> formats, respectively. If a datetime type is provided for a column, (see the <a href="#types">types</a> argument), then the <code>dateformat</code> format string needs to match the format of values in that column, otherwise, a warning will be emitted and the value will be replaced with a <code>missing</code> value (this behavior is also configurable via the <a href="#strict">strict</a> and <a href="#strict">silencewarnings</a> arguments). If an <code>AbstractDict</code> is provided, different <code>dateformat</code> strings can be provided for specific columns; the provided dict can map either an <code>Integer</code> for column number, or a <code>String</code> or <code>Symbol</code> for column name to the dateformat string that should be used for that column. Columns not mapped in the dict argument will use the default format strings mentioned above.</p><h3 id="Examples-16"><a class="docs-heading-anchor" href="#Examples-16">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-16" title="Permalink"></a></h3><ul><li><a href="examples/#dateformat_example">DateFormat</a></li></ul><h2 id="decimal"><a class="docs-heading-anchor" href="#decimal"><code>decimal</code></a><a id="decimal-1"></a><a class="docs-heading-anchor-permalink" href="#decimal" title="Permalink"></a></h2><p>An ASCII <code>Char</code> argument that is used when parsing float values that indicates where the fractional portion of the float value begins. i.e. for the truncated values of pie <code>3.14</code>, the <code>&#39;.&#39;</code> character separates the <code>3</code> and <code>14</code> values, whereas for <code>3,14</code> (common European notation), the <code>&#39;,&#39;</code> character separates the fractional portion. By default, <code>decimal=&#39;.&#39;</code>.</p><h3 id="Examples-17"><a class="docs-heading-anchor" href="#Examples-17">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-17" title="Permalink"></a></h3><ul><li><a href="examples/#decimal_example">Custom decimal separator</a></li></ul><h2 id="truestrings"><a class="docs-heading-anchor" href="#truestrings"><code>truestrings</code> / <code>falsestrings</code></a><a id="truestrings-1"></a><a class="docs-heading-anchor-permalink" href="#truestrings" title="Permalink"></a></h2><p>These arguments can be provided as <code>Vector{String}</code> to specify custom values that should be treated as the <code>Bool</code> <code>true</code>/<code>false</code> values for all the columns of a data input. By default, <code>[&quot;true&quot;, &quot;True&quot;, &quot;TRUE&quot;, &quot;T&quot;, &quot;1&quot;]</code> string values are used to detect <code>true</code> values, and <code>[&quot;false&quot;, &quot;False&quot;, &quot;FALSE&quot;, &quot;F&quot;, &quot;0&quot;]</code> string values are used to detect <code>false</code> values. Note that even though <code>&quot;1&quot;</code> and <code>&quot;0&quot;</code> <em>can</em> be used to parse <code>true</code>/<code>false</code> values, in terms of <em>auto</em> detecting column types, those values will be parsed as <code>Int64</code> first, instead of <code>Bool</code>. To instead parse those values as <code>Bool</code>s for a column, you can manually provide that column&#39;s type as <code>Bool</code> (see the <a href="#types">type</a> argument).</p><h3 id="Examples-18"><a class="docs-heading-anchor" href="#Examples-18">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-18" title="Permalink"></a></h3><ul><li><a href="examples/#truestrings_example">Custom bool strings</a></li></ul><h2 id="types"><a class="docs-heading-anchor" href="#types"><code>types</code></a><a id="types-1"></a><a class="docs-heading-anchor-permalink" href="#types" title="Permalink"></a></h2><p>Argument to control the types of columns that get parsed in the data input. Can be provided as a single <code>Type</code>, an <code>AbstractVector</code> of types, or an <code>AbstractDict</code>. If a single type is provided, like <code>types=Float64</code>, then <em>all</em> columns in the data input will be parsed as <code>Float64</code>. If a column&#39;s value isn&#39;t a valid <code>Float64</code> value, then a warning will be emitted, unless <code>silencewarnings=false</code> is passed, then no warning will be printed. However, if <code>strict=true</code> is passed, then an error will be thrown instead, regarldess of the <code>silencewarnings</code> argument. The <code>types</code> argument can also be provided as an <code>AbstractVector{Type}</code>, wherein the length of the vector should match the number of columns in the data input, and each element gives the type of the corresponding column in order. If provided as an <code>AbstractDict</code>, then specific columns can have their column type specified, with the key of the dict being an <code>Integer</code> for column number, or <code>String</code> or <code>Symbol</code> for column name, and the dict value being the column type. Unspecified columns will have their column type auto-detected while parsing. By default, <code>types=nothing</code>, which means all column types in the data input will be detected while parsing. Note that it isn&#39;t necessary to pass <code>types=Union{Float64, Missing}</code> if the data input contains <code>missing</code> values. Parsing will detect <code>missing</code> values if present, and promote any manually provided column types from the singular (<code>Float64</code>) to the missing equivalent (<code>Union{Float64, Missing}</code>) automatically. Standard types will be auto-detected in the following order when not otherwise specified:  <code>Int64</code>, <code>Float64</code>, <code>Date</code>, <code>DateTime</code>, <code>Time</code>, <code>Bool</code>, <code>String</code>.</p><p>Non-standard types can be provided, like <code>Dec64</code> from the DecFP.jl package, but must support the <code>Base.tryparse(T, str)</code> function for parsing a value from a string. This allows, for example, easily defining a custom type, like <code>struct Float64Array; values::Vector{Float64}; end</code>, as long as a corresponding <code>Base.tryparse</code> definition is defined, like <code>Base.tryparse(::Type{Float64Array}, str) = Float64Array(map(x -&gt; parse(Float64, x), split(str, &#39;;&#39;)))</code>, where a single cell in the data input is like <code>1.23;4.56;7.89</code>.</p><p>Note that the default <a href="#stringtype">stringtype</a> can be overridden by providing a column&#39;s type manually, like <code>CSV.File(source; types=Dict(1 =&gt; String), stringtype=PosLenString)</code>, where the first column will be parsed as a <code>String</code>, while any other string columns will have the <code>PosLenString</code> type.</p><h3 id="Examples-19"><a class="docs-heading-anchor" href="#Examples-19">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-19" title="Permalink"></a></h3><ul><li><a href="examples/#matrix_example">Matrix-like Data</a></li><li><a href="examples/#types_example">Providing types</a></li></ul><h2 id="typemap"><a class="docs-heading-anchor" href="#typemap"><code>typemap</code></a><a id="typemap-1"></a><a class="docs-heading-anchor-permalink" href="#typemap" title="Permalink"></a></h2><p>A <code>Dict{Type, Type}</code> argument that allows replacing a non-<code>String</code> standard type with another type when a column&#39;s type is auto-detected. Most commonly, this would be used to force all numeric columns to be <code>Float64</code>, like <code>typemap=Dict(Int64 =&gt; Float64)</code>, which would cause any columns detected as <code>Int64</code> to be parsed as <code>Float64</code> instead. Another common case would be wanting all columns of a specific type to be parsed as strings instead, like <code>typemap=Dict(Date =&gt; String)</code>, which will cause any columns detected as <code>Date</code> to be parsed as <code>String</code> instead.</p><h3 id="Examples-20"><a class="docs-heading-anchor" href="#Examples-20">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-20" title="Permalink"></a></h3><ul><li><a href="examples/#typemap_example">Typemap</a></li></ul><h2 id="pool"><a class="docs-heading-anchor" href="#pool"><code>pool</code></a><a id="pool-1"></a><a class="docs-heading-anchor-permalink" href="#pool" title="Permalink"></a></h2><p>Argument that controls whether columns will be returned as <code>PooledArray</code>s. Can be provided as a <code>Bool</code>, <code>Float64</code>, vector of <code>Bool</code> or <code>Float64</code>, or dict mapping column number/name to <code>Bool</code> or <code>Float64</code>. As a <code>Bool</code>, controls absolutely whether a column will be pooled or not; if passed as a single <code>Bool</code> argument like <code>pool=true</code>, then all string columns will be pooled, regardless of cardinality. When passed as a <code>Float64</code>, the value should be between <code>0.0</code> and <code>1.0</code> indicating the threshold under which the % of unique values found in the column will result in the column being pooled. For example, if <code>pool=0.1</code>, then all string columns with a unique value % less than 10% will be returned as <code>PooledArray</code>, while other string columns will be normal string vectors. As mentioned, when the <code>pool</code> argument is a single <code>Bool</code> or <code>Float64</code>, only string columns will be considered for pooling. When a vector or dict is provided, the pooling for any column can be provided as a <code>Bool</code> or <code>Float64</code>. Similar to the <a href="#types">types</a> argument, providing a vector to <code>pool</code> should have an element for each column in the data input, while a dict argument can map column number/name to <code>Bool</code> or <code>Float64</code> for specific columns. Unspecified columns will not be pooled when the argument is a dict.</p><h3 id="Examples-21"><a class="docs-heading-anchor" href="#Examples-21">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-21" title="Permalink"></a></h3><ul><li><a href="examples/#pool_example">Pooled values</a></li></ul><h2 id="downcast"><a class="docs-heading-anchor" href="#downcast"><code>downcast</code></a><a id="downcast-1"></a><a class="docs-heading-anchor-permalink" href="#downcast" title="Permalink"></a></h2><p>A <code>Bool</code> argument that controls whether <code>Integer</code> detected column types will be &quot;shrunk&quot; to the smallest possible integer type. Argument is <code>false</code> by default. Only applies to auto-detected column types; i.e. if a column type is provided manually as <code>Int64</code>, it will not be shrunk. Useful for shrinking the overall memory footprint of parsed data, though care should be taken when processing the results as Julia by default as <a href="https://en.wikipedia.org/wiki/Integer_overflow">integer overflow</a> behavior, which is increasingly likely the smaller the integer type.</p><h2 id="stringtype"><a class="docs-heading-anchor" href="#stringtype"><code>stringtype</code></a><a id="stringtype-1"></a><a class="docs-heading-anchor-permalink" href="#stringtype" title="Permalink"></a></h2><p>An argument that controls the precise type of string columns. Supported values are <code>InlineString</code> (the default), <code>PosLenString</code>, or <code>String</code>. The various string types are aimed at being mostly transparent to most users. In certain workflows, however, it can be advantageous to be more specific. Here&#39;s a quick rundown of the possible options:</p><ul><li><code>InlineString</code>: a set of fixed-width, stack-allocated primitive types. Can take memory pressure off the GC because they aren&#39;t reference types/on the heap. For very large files with string columns that have a fairly low variance in string length, this can provide much better GC interaction than <code>String</code>. When string length has a high variance, it can lead to lots of &quot;wasted space&quot;, since an entire column will be promoted to the smallest InlineString type that fits the longest string value. For small strings, that can mean a lot of wasted space when they&#39;re promoted to a high fixed-width.</li><li><code>PosLenString</code>: results in columns returned as <code>PosLenStringVector</code> (or <code>ChainedVector{PosLenStringVector}</code> for the multithreaded case), which holds a reference to the original input data, and acts as one large &quot;view&quot; vector into the original data where each cell begins/ends. Can result in the smallest memory footprint for string columns. <code>PosLenStringVector</code>, however, does not support traditional mutable operations like regular <code>Vector</code>s, like <code>push!</code>, <code>append!</code>, or <code>deleteat!</code>.</li><li><code>String</code>: each string must be heap-allocated, which can result in higher GC pressure in very large files. But columns are returned as normal <code>Vector{String}</code> (or <code>ChainedVector{Vector{String}}</code>), which can be processed normally, including any mutating operations.</li></ul><h2 id="strict"><a class="docs-heading-anchor" href="#strict"><code>strict</code> / <code>silencewarnings</code> / <code>maxwarnings</code></a><a id="strict-1"></a><a class="docs-heading-anchor-permalink" href="#strict" title="Permalink"></a></h2><p>Arguments that control error behavior when invalid values are encountered while parsing. Only applicable when types are provided manually by the user via the <a href="#types">types</a> argument. If a column type is manually provided, but an invalid value is encountered, the default behavior is to set the value for that cell to <code>missing</code>, emit a warning (i.e. <code>silencewarnings=false</code> and <code>strict=false</code>), but only up to 100 total warnings and then they&#39;ll be silenced (i.e. <code>maxwarnings=100</code>). If <code>strict=true</code>, then invalid values will result in an error being thrown instead of any warnings emitted.</p><h2 id="debug"><a class="docs-heading-anchor" href="#debug"><code>debug</code></a><a id="debug-1"></a><a class="docs-heading-anchor-permalink" href="#debug" title="Permalink"></a></h2><p>A <code>Bool</code> argument that controls the printing of extra &quot;debug&quot; information while parsing. Can be useful if parsing doesn&#39;t produce the expected result or a bug is suspected in parsing somehow.</p><h1 id="Common-terms"><a class="docs-heading-anchor" href="#Common-terms">Common terms</a><a id="Common-terms-1"></a><a class="docs-heading-anchor-permalink" href="#Common-terms" title="Permalink"></a></h1><h3 id="Standard-types"><a class="docs-heading-anchor" href="#Standard-types">Standard types</a><a id="Standard-types-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-types" title="Permalink"></a></h3><p>The types that are detected by default when column types are not provided by the user otherwise. They include: <code>Int64</code>, <code>Float64</code>, <code>Date</code>, <code>DateTime</code>, <code>Time</code>, <code>Bool</code>, and <code>String</code>.</p><h3 id="newlines"><a class="docs-heading-anchor" href="#newlines">Newlines</a><a id="newlines-1"></a><a class="docs-heading-anchor-permalink" href="#newlines" title="Permalink"></a></h3><p>For all parsing functionality, newlines are detected/parsed automatically, regardless if they&#39;re present in the data as a single newline character (<code>&#39;\n&#39;</code>), single return character (&#39;<code>\r&#39;</code>), or full CRLF sequence (<code>&quot;\r\n&quot;</code>).</p><h3 id="Cardinality"><a class="docs-heading-anchor" href="#Cardinality">Cardinality</a><a id="Cardinality-1"></a><a class="docs-heading-anchor-permalink" href="#Cardinality" title="Permalink"></a></h3><p>Refers to the ratio of unique values to total number of values in a column. Columns with &quot;low cardinality&quot; have a low % of unique values, or put another way, there are only a few unique values for the entire column of data where unique values are repeated many times. Columns with &quot;high cardinality&quot; have a high % of unique values relative to total number of values. Think of these as &quot;id-like&quot; columns where each or almost each value is a unique identifier with no (or few) repeated values.</p><h1 id="Writing"><a class="docs-heading-anchor" href="#Writing">Writing</a><a id="Writing-1"></a><a class="docs-heading-anchor-permalink" href="#Writing" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="CSV.write" href="#CSV.write"><code>CSV.write</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">CSV.write(file, table; kwargs...) =&gt; file
table |&gt; CSV.write(file; kwargs...) =&gt; file</code></pre><p>Write a <a href="https://github.com/JuliaData/Tables.jl">Tables.jl interface input</a> to a csv file, given as an <code>IO</code> argument or <code>String</code>/FilePaths.jl type representing the file name to write to. Alternatively, <code>CSV.RowWriter</code> creates a row iterator, producing a csv-formatted string for each row in an input table.</p><p>Supported keyword arguments include:</p><ul><li><code>bufsize::Int=2^22</code>: The length of the buffer to use when writing each csv-formatted row; default 4MB; if a row is larger than the <code>bufsize</code> an error is thrown</li><li><code>delim::Union{Char, String}=&#39;,&#39;</code>: a character or string to print out as the file&#39;s delimiter</li><li><code>quotechar::Char=&#39;&quot;&#39;</code>: ascii character to use for quoting text fields that may contain delimiters or newlines</li><li><code>openquotechar::Char</code>: instead of <code>quotechar</code>, use <code>openquotechar</code> and <code>closequotechar</code> to support different starting and ending quote characters</li><li><code>escapechar::Char=&#39;&quot;&#39;</code>: ascii character used to escape quote characters in a text field</li><li><code>missingstring::String=&quot;&quot;</code>: string to print for <code>missing</code> values</li><li><code>dateformat=Dates.default_format(T)</code>: the date format string to use for printing out <code>Date</code> &amp; <code>DateTime</code> columns</li><li><code>append=false</code>: whether to append writing to an existing file/IO, if <code>true</code>, it will not write column names by default</li><li><code>writeheader=!append</code>: whether to write an initial row of delimited column names, not written by default if appending</li><li><code>header</code>: pass a list of column names (Symbols or Strings) to use instead of the column names of the input table</li><li><code>newline=&#39;\n&#39;</code>: character or string to use to separate rows (lines in the csv file)</li><li><code>quotestrings=false</code>: whether to force all strings to be quoted or not</li><li><code>decimal=&#39;.&#39;</code>: character to use as the decimal point when writing floating point numbers</li><li><code>transform=(col,val)-&gt;val</code>: a function that is applied to every cell e.g. we can transform all <code>nothing</code> values to <code>missing</code> using <code>(col, val) -&gt; something(val, missing)</code></li><li><code>bom=false</code>: whether to write a UTF-8 BOM header (0xEF 0xBB 0xBF) or not</li><li><code>partition::Bool=false</code>: by passing <code>true</code>, the <code>table</code> argument is expected to implement <code>Tables.partitions</code> and the <code>file</code> argument can either be an indexable collection of <code>IO</code>, file <code>String</code>s, or a single file <code>String</code> that will have an index appended to the name</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using CSV, Tables, DataFrames

# write out a DataFrame to csv file
df = DataFrame(rand(10, 10), :auto)
CSV.write(&quot;data.csv&quot;, df)

# write a matrix to an in-memory IOBuffer
io = IOBuffer()
mat = rand(10, 10)
CSV.write(io, Tables.table(mat))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/CSV.jl/blob/61c1b0b3da17abb88fa2cea7bed13bb601762300/src/write.jl#LL1-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CSV.RowWriter" href="#CSV.RowWriter"><code>CSV.RowWriter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CSV.RowWriter(table; kwargs...)</code></pre><p>Creates an iterator that produces csv-formatted strings for each row in the input table.</p><p>Supported keyword arguments include:</p><ul><li><code>bufsize::Int=2^22</code>: The length of the buffer to use when writing each csv-formatted row; default 4MB; if a row is larger than the <code>bufsize</code> an error is thrown</li><li><code>delim::Union{Char, String}=&#39;,&#39;</code>: a character or string to print out as the file&#39;s delimiter</li><li><code>quotechar::Char=&#39;&quot;&#39;</code>: ascii character to use for quoting text fields that may contain delimiters or newlines</li><li><code>openquotechar::Char</code>: instead of <code>quotechar</code>, use <code>openquotechar</code> and <code>closequotechar</code> to support different starting and ending quote characters</li><li><code>escapechar::Char=&#39;&quot;&#39;</code>: ascii character used to escape quote characters in a text field</li><li><code>missingstring::String=&quot;&quot;</code>: string to print for <code>missing</code> values</li><li><code>dateformat=Dates.default_format(T)</code>: the date format string to use for printing out <code>Date</code> &amp; <code>DateTime</code> columns</li><li><code>header</code>: pass a list of column names (Symbols or Strings) to use instead of the column names of the input table</li><li><code>newline=&#39;\n&#39;</code>: character or string to use to separate rows (lines in the csv file)</li><li><code>quotestrings=false</code>: whether to force all strings to be quoted or not</li><li><code>decimal=&#39;.&#39;</code>: character to use as the decimal point when writing floating point numbers</li><li><code>transform=(col,val)-&gt;val</code>: a function that is applied to every cell e.g. we can transform all <code>nothing</code> values to <code>missing</code> using <code>(col, val) -&gt; something(val, missing)</code></li><li><code>bom=false</code>: whether to write a UTF-8 BOM header (0xEF 0xBB 0xBF) or not</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/CSV.jl/blob/61c1b0b3da17abb88fa2cea7bed13bb601762300/src/write.jl#LL62-L81">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Friday 20 August 2021 20:41">Friday 20 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
