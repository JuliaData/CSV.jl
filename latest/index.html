<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CSV.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>CSV.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Home</a></li></ul><a class="edit-page" href="https://github.com/JuliaData/CSV.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="CSV.jl-Documentation-1" href="#CSV.jl-Documentation-1">CSV.jl Documentation</a></h1><p>CSV.jl is built to be a fast and flexible pure-Julia library for handling delimited text files.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSV.File" href="#CSV.File"><code>CSV.File</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CSV.File(source::Union{String, IO}; kwargs...) =&gt; CSV.File</code></pre><p>Read a csv input (a filename given as a String, or any other IO source), returning a <code>CSV.File</code> object. Opens the file and uses passed arguments to detect the number of columns and column types. The returned <code>CSV.File</code> object supports the <a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a> interface and can iterate <code>CSV.Row</code>s. <code>CSV.Row</code> supports <code>propertynames</code> and <code>getproperty</code> to access individual row values. Note that duplicate column names will be detected and adjusted to ensure uniqueness (duplicate column name <code>a</code> will become <code>a_1</code>). For example, one could iterate over a csv file with column names <code>a</code>, <code>b</code>, and <code>c</code> by doing:</p><pre><code class="language-julia">for row in CSV.File(file)
    println(&quot;a=$(row.a), b=$(row.b), c=$(row.c)&quot;)
end</code></pre><p>By supporting the Tables.jl interface, a <code>CSV.File</code> can also be a table input to any other table sink function. Like:</p><pre><code class="language-julia"># materialize a csv file as a DataFrame
df = CSV.File(file) |&gt; DataFrame

# load a csv file directly into an sqlite database table
db = SQLite.DB()
tbl = CSV.File(file) |&gt; SQLite.load!(db, &quot;sqlite_table&quot;)</code></pre><p>Supported keyword arguments include:</p><ul><li>File layout options:<ul><li><code>header=1</code>: the <code>header</code> argument can be an <code>Int</code>, indicating the row to parse for column names; or a <code>Range</code>, indicating a span of rows to be combined together as column names; or an entire <code>Vector of Symbols</code> or <code>Strings</code> to use as column names</li><li><code>normalizenames=false</code>: whether column names should be &quot;normalized&quot; into valid Julia identifier symbols</li><li><code>datarow</code>: an <code>Int</code> argument to specify the row where the data starts in the csv file; by default, the next row after the <code>header</code> row is used</li><li><code>skipto::Int</code>: similar to <code>datarow</code>, specifies the number of rows to skip before starting to read data</li><li><code>footerskip::Int</code>: number of rows at the end of a file to skip parsing</li><li><code>limit</code>: an <code>Int</code> to indicate a limited number of rows to parse in a csv file</li><li><code>transpose::Bool</code>: read a csv file &quot;transposed&quot;, i.e. each column is parsed as a row</li><li><code>comment</code>: a <code>String</code> that occurs at the beginning of a line to signal parsing that row should be skipped</li><li><code>use_mmap::Bool=!Sys.iswindows()</code>: whether the file should be mmapped for reading, which in some cases can be faster</li></ul></li><li>Parsing options:<ul><li><code>missingstrings</code>, <code>missingstring</code>: either a <code>String</code>, or <code>Vector{String}</code> to use as sentinel values that will be parsed as <code>missing</code>; by default, only an empty field (two consecutive delimiters) is considered <code>missing</code></li><li><code>delim=&#39;,&#39;</code>: a <code>Char</code> or <code>String</code> that indicates how columns are delimited in a file</li><li><code>ignorerepeated::Bool=false</code>: whether repeated (consecutive) delimiters should be ignored while parsing; useful for fixed-width files with delimiter padding between cells</li><li><code>quotechar=&#39;&quot;&#39;</code>, <code>openquotechar</code>, <code>closequotechar</code>: a <code>Char</code> (or different start and end characters) that indicate a quoted field which may contain textual delimiters or newline characters</li><li><code>escapechar=&#39;&quot;&#39;</code>: the <code>Char</code> used to escape quote characters in a text field</li><li><code>dateformat::Union{String, Dates.DateFormat, Nothing}</code>: a date format string to indicate how Date/DateTime columns are formatted in a delimited file</li><li><code>decimal</code>: a <code>Char</code> indicating how decimals are separated in floats, i.e. <code>3.14</code> used &#39;.&#39;, or <code>3,14</code> uses a comma &#39;,&#39;</li><li><code>truestrings</code>, <code>falsestrings</code>: <code>Vectors of Strings</code> that indicate how <code>true</code> or <code>false</code> values are represented</li></ul></li><li>Column Type Options:<ul><li><code>types</code>: a Vector or Dict of types to be used for column types; a Dict can map column index <code>Int</code>, or name <code>Symbol</code> or <code>String</code> to type for a column, i.e. Dict(1=&gt;Float64) will set the first column as a Float64, Dict(:column1=&gt;Float64) will set the column named column1 to Float64 and, Dict(&quot;column1&quot;=&gt;Float64) will set the column1 to Float64</li><li><code>typemap::Dict{Type, Type}</code>: a mapping of a type that should be replaced in every instance with another type, i.e. <code>Dict(Float64=&gt;String)</code> would change every detected <code>Float64</code> column to be parsed as <code>Strings</code></li><li><code>allowmissing=:all</code>: indicate how missing values are allowed in columns; possible values are <code>:all</code> - all columns may contain missings, <code>:auto</code> - auto-detect columns that contain missings or, <code>:none</code> - no columns may contain missings</li><li><code>categorical::Union{Bool, Real}=false</code>: if <code>true</code>, columns detected as <code>String</code> are returned as a <code>CategoricalArray</code>; alternatively, the proportion of unique values below which <code>String</code> columns should be treated as categorical (for example 0.1 for 10%)</li><li><code>strict::Bool=false</code>: whether invalid values should throw a parsing error or be replaced with missing values</li><li><code>silencewarnings::Bool=false</code>: whether invalid value warnings should be silenced (requires <code>strict=false</code>)</li></ul></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/CSV.jl/blob/da5bcbb53a3f4b02eb1d71b0849a5f88e1d12fe0/src/CSV.jl#L44-L98">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSV.read" href="#CSV.read"><code>CSV.read</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>CSV.read(fullpath::Union{AbstractString,IO}, sink=DataFrame; kwargs...)</code> =&gt; <code>typeof(sink)</code></p><p>Parses a delimited file into a Julia structure (a DataFrame by default, but any valid Tables.jl sink function can be provided).</p><p>Minimal error-reporting happens w/ <code>CSV.read</code> for performance reasons; for problematic csv files, try <a href="index.html#CSV.validate"><code>CSV.validate</code></a> which takes exact same arguments as <code>CSV.read</code> and provides much more information for why reading the file failed.</p><p>Positional arguments:</p><ul><li><code>fullpath</code>: can be a file name (String) of the location of the csv file or <code>IO</code> object to read the csv from directly</li><li><code>sink</code>: <code>DataFrame</code> by default, but may also be any other Tables.jl sink function</li></ul><p>Supported keyword arguments include:</p><ul><li>File layout options:<ul><li><code>header=1</code>: the <code>header</code> argument can be an <code>Int</code>, indicating the row to parse for column names; or a <code>Range</code>, indicating a span of rows to be combined together as column names; or an entire <code>Vector of Symbols</code> or <code>Strings</code> to use as column names</li><li><code>normalizenames=false</code>: whether column names should be &quot;normalized&quot; into valid Julia identifier symbols</li><li><code>datarow</code>: an <code>Int</code> argument to specify the row where the data starts in the csv file; by default, the next row after the <code>header</code> row is used</li><li><code>skipto::Int</code>: similar to <code>datarow</code>, specifies the number of rows to skip before starting to read data</li><li><code>footerskip::Int</code>: number of rows at the end of a file to skip parsing</li><li><code>limit</code>: an <code>Int</code> to indicate a limited number of rows to parse in a csv file</li><li><code>transpose::Bool</code>: read a csv file &quot;transposed&quot;, i.e. each column is parsed as a row</li><li><code>comment</code>: a <code>String</code> that occurs at the beginning of a line to signal parsing that row should be skipped</li><li><code>use_mmap::Bool=!Sys.iswindows()</code>: whether the file should be mmapped for reading, which in some cases can be faster</li></ul></li><li>Parsing options:<ul><li><code>missingstrings</code>, <code>missingstring</code>: either a <code>String</code>, or <code>Vector{String}</code> to use as sentinel values that will be parsed as <code>missing</code>; by default, only an empty field (two consecutive delimiters) is considered <code>missing</code></li><li><code>delim=&#39;,&#39;</code>: a <code>Char</code> or <code>String</code> that indicates how columns are delimited in a file</li><li><code>ignorerepeated::Bool=false</code>: whether repeated (consecutive) delimiters should be ignored while parsing; useful for fixed-width files with delimiter padding between cells</li><li><code>quotechar=&#39;&quot;&#39;</code>, <code>openquotechar</code>, <code>closequotechar</code>: a <code>Char</code> (or different start and end characters) that indicate a quoted field which may contain textual delimiters or newline characters</li><li><code>escapechar=&#39;\&#39;</code>: the <code>Char</code> used to escape quote characters in a text field</li><li><code>dateformat::Union{String, Dates.DateFormat, Nothing}</code>: a date format string to indicate how Date/DateTime columns are formatted in a delimited file</li><li><code>decimal</code>: a <code>Char</code> indicating how decimals are separated in floats, i.e. <code>3.14</code> used &#39;.&#39;, or <code>3,14</code> uses a comma &#39;,&#39;</li><li><code>truestrings</code>, <code>falsestrings</code>: <code>Vectors of Strings</code> that indicate how <code>true</code> or <code>false</code> values are represented</li></ul></li><li>Column Type Options:<ul><li><code>types</code>: a Vector or Dict of types to be used for column types; a Dict can map column index <code>Int</code>, or name <code>Symbol</code> or <code>String</code> to type for a column, i.e. Dict(1=&gt;Float64) will set the first column as a Float64, Dict(:column1=&gt;Float64) will set the column named column1 to Float64 and, Dict(&quot;column1&quot;=&gt;Float64) will set the column1 to Float64</li><li><code>typemap::Dict{Type, Type}</code>: a mapping of a type that should be replaced in every instance with another type, i.e. <code>Dict(Float64=&gt;String)</code> would change every detected <code>Float64</code> column to be parsed as <code>Strings</code></li><li><code>allowmissing=:all</code>: indicate how missing values are allowed in columns; possible values are <code>:all</code> - all columns may contain missings, <code>:auto</code> - auto-detect columns that contain missings or, <code>:none</code> - no columns may contain missings</li><li><code>categorical::Union{Bool, Real}=false</code>: if <code>true</code>, columns detected as <code>String</code> are returned as a <code>CategoricalArray</code>; alternatively, the proportion of unique values below which <code>String</code> columns should be treated as categorical (for example 0.1 for 10%)</li><li><code>strict::Bool=false</code>: whether invalid values should throw a parsing error or be replaced with missing values</li></ul></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/CSV.jl/blob/da5bcbb53a3f4b02eb1d71b0849a5f88e1d12fe0/src/CSV.jl#L258-L296">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSV.validate" href="#CSV.validate"><code>CSV.validate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>CSV.validate(fullpath::Union{AbstractString,IO}, sink::Type{T}=DataFrame, args...; kwargs...)</code> =&gt; <code>typeof(sink)</code></p><p><code>CSV.validate(fullpath::Union{AbstractString,IO}, sink::Data.Sink; kwargs...)</code> =&gt; <code>Data.Sink</code></p><p>Takes the same positional &amp; keyword arguments as <a href="index.html#CSV.read"><code>CSV.read</code></a>, but provides detailed information as to why reading a csv file failed. Useful for cases where reading fails and it&#39;s not clear whether it&#39;s due to a row having too many columns, or wrong types, or what have you.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/CSV.jl/blob/da5bcbb53a3f4b02eb1d71b0849a5f88e1d12fe0/src/validate.jl#L9-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSV.write" href="#CSV.write"><code>CSV.write</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CSV.write(file::Union{String, IO}, file; kwargs...) =&gt; file
table |&gt; CSV.write(file::Union{String, IO}; kwargs...) =&gt; file</code></pre><p>Write a <a href="https://github.com/JuliaData/Tables.jl">Tables.jl interface input</a> to a csv file, given as an <code>IO</code> argument or String representing the file name to write to.</p><p>Keyword arguments include:</p><ul><li><code>delim::Union{Char, String}=&#39;,&#39;</code>: a character or string to print out as the file&#39;s delimiter</li><li><code>quotechar::Char=&#39;&quot;&#39;</code>: character to use for quoting text fields that may contain delimiters or newlines</li><li><code>openquotechar::Char</code>: instead of <code>quotechar</code>, use <code>openquotechar</code> and <code>closequotechar</code> to support different starting and ending quote characters</li><li><code>escapechar::Char=&#39;\&#39;</code>: character used to escape quote characters in a text field</li><li><code>missingstring::String=&quot;&quot;</code>: string to print </li><li><code>dateformat=Dates.default_format(T)</code>: the date format string to use for printing out Date &amp; DateTime columns</li><li><code>append=false</code>: whether to append writing to an existing file/IO, if <code>true</code>, it will not write column names by default</li><li><code>writeheader=!append</code>: whether to write an initial row of delimited column names, not written by default if appending</li><li><code>header</code>: pass a list of column names (Symbols or Strings) to use instead of the column names of the input table</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/CSV.jl/blob/da5bcbb53a3f4b02eb1d71b0849a5f88e1d12fe0/src/write.jl#L1-L17">source</a></section><footer><hr/></footer></article></body></html>
