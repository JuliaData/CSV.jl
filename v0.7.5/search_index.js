var documenterSearchIndex = {"docs":
[{"location":"#CSV.jl-Documentation-1","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"CSV.jl is built to be a fast and flexible pure-Julia library for handling delimited text files.","category":"page"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"Depth = 3","category":"page"},{"location":"#Getting-Started-1","page":"CSV.jl Documentation","title":"Getting Started","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"CSV.jl provides a number of utilities for working with delimited files. CSV.File provides a way to read files into columns of data, detecting column types. CSV.Rows provides a row iterator for looping over rows in a file. Inputs to either should be filenames as Strings, or byte vectors (AbstractVector{UInt8}). To read other IO inputs, just call read(io) and pass the bytes directly to CSV.File or CSV.Rows.","category":"page"},{"location":"#Key-Functions-1","page":"CSV.jl Documentation","title":"Key Functions","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"CSV.File\nCSV.Chunks\nCSV.Rows\nCSV.write\nCSV.RowWriter","category":"page"},{"location":"#CSV.File","page":"CSV.jl Documentation","title":"CSV.File","text":"CSV.File(source; kwargs...) => CSV.File\n\nRead a UTF-8 CSV input and return a CSV.File object.\n\nThe source argument can be one of:\n\nfilename given as a string or FilePaths.jl type\nan AbstractVector{UInt8} like a byte buffer or codeunits(string)\nan IOBuffer\n\nTo read a csv file from a url, use the HTTP.jl package, where the HTTP.Response body can be passed like:\n\nf = CSV.File(HTTP.get(url).body)\n\nFor other IO or Cmd inputs, you can pass them like: f = CSV.File(read(obj)).\n\nOpens the file and uses passed arguments to detect the number of columns and column types, unless column types are provided manually via the types keyword argument. Note that passing column types manually can slightly increase performance for each column type provided (column types can be given as a Vector for all columns, or specified per column via name or index in a Dict).\n\nFor text encodings other than UTF-8, load the StringEncodings.jl package and call e.g. CSV.File(open(read, source, enc\"ISO-8859-1\")).\n\nThe returned CSV.File object supports the Tables.jl interface and can iterate CSV.Rows. CSV.Row supports propertynames and getproperty to access individual row values. CSV.File also supports entire column access like a DataFrame via direct property access on the file object, like f = CSV.File(file); f.col1. Note that duplicate column names will be detected and adjusted to ensure uniqueness (duplicate column name a will become a_1). For example, one could iterate over a csv file with column names a, b, and c by doing:\n\nfor row in CSV.File(file)\n    println(\"a=$(row.a), b=$(row.b), c=$(row.c)\")\nend\n\nBy supporting the Tables.jl interface, a CSV.File can also be a table input to any other table sink function. Like:\n\n# materialize a csv file as a DataFrame, without copying columns from CSV.File\ndf = CSV.File(file) |> DataFrame!\n\n# load a csv file directly into an sqlite database table\ndb = SQLite.DB()\ntbl = CSV.File(file) |> SQLite.load!(db, \"sqlite_table\")\n\nSupported keyword arguments include:\n\nFile layout options:\nheader=1: the header argument can be an Int, indicating the row to parse for column names; or a Range, indicating a span of rows to be concatenated together as column names; or an entire Vector{Symbol} or Vector{String} to use as column names; if a file doesn't have column names, either provide them as a Vector, or set header=0 or header=false and column names will be auto-generated (Column1, Column2, etc.)\nnormalizenames=false: whether column names should be \"normalized\" into valid Julia identifier symbols; useful when iterating rows and accessing column values of a row via getproperty (e.g. row.col1)\ndatarow: an Int argument to specify the row where the data starts in the csv file; by default, the next row after the header row is used. If header=0, then the 1st row is assumed to be the start of data; providing a datarow or skipto argument does not affect the header argument\nskipto::Int: identical to datarow, specifies the number of rows to skip before starting to read data\nfooterskip::Int: number of rows at the end of a file to skip parsing\nlimit: an Int to indicate a limited number of rows to parse in a csv file; use in combination with skipto to read a specific, contiguous chunk within a file; note for large files when multiple threads are used for parsing, the limit argument may not result in exact an exact # of rows parsed; use threaded=false to ensure an exact limit if necessary\ntranspose::Bool: read a csv file \"transposed\", i.e. each column is parsed as a row\ncomment: rows that begin with this String will be skipped while parsing\nignoreemptylines::Bool=false: whether empty rows/lines in a file should be ignored (if false, each column will be assigned missing for that empty row)\nthreaded::Bool: whether parsing should utilize multiple threads; by default threads are used on large enough files, but isn't allowed when transpose=true; only available in Julia 1.3+\ntasks::Integer=Threads.nthreads(): for multithreaded parsing, this controls the number of tasks spawned to read a file in chunks concurrently; defaults to the # of threads Julia was started with (i.e. JULIA_NUM_THREADS environment variable)\nselect: an AbstractVector of Int, Symbol, String, or Bool, or a \"selector\" function of the form (i, name) -> keep::Bool; only columns in the collection or for which the selector function returns true will be parsed and accessible in the resulting CSV.File. Invalid values in select are ignored.\ndrop: inverse of select; an AbstractVector of Int, Symbol, String, or Bool, or a \"drop\" function of the form (i, name) -> drop::Bool; columns in the collection or for which the drop function returns true will ignored in the resulting CSV.File. Invalid values in drop are ignored.\nParsing options:\nmissingstrings, missingstring: either a String, or Vector{String} to use as sentinel values that will be parsed as missing; by default, only an empty field (two consecutive delimiters) is considered missing\ndelim=',': a Char or String that indicates how columns are delimited in a file; if no argument is provided, parsing will try to detect the most consistent delimiter on the first 10 rows of the file\nignorerepeated::Bool=false: whether repeated (consecutive) delimiters should be ignored while parsing; useful for fixed-width files with delimiter padding between cells\nquotechar='\"', openquotechar, closequotechar: a Char (or different start and end characters) that indicate a quoted field which may contain textual delimiters or newline characters\nescapechar='\"': the Char used to escape quote characters in a quoted field\ndateformat::Union{String, Dates.DateFormat, Nothing}: a date format string to indicate how Date/DateTime columns are formatted for the entire file\ndateformats::Union{AbstractDict, Nothing}: a Dict of date format strings to indicate how the Date/DateTime columns corresponding to the keys are formatted. The Dict can map column index Int, or name Symbol or String to the format string for that column.\ndecimal='.': a Char indicating how decimals are separated in floats, i.e. 3.14 used '.', or 3,14 uses a comma ','\ntruestrings, falsestrings: Vectors of Strings that indicate how true or false values are represented; by default only true and false are treated as Bool\nColumn Type Options:\ntype: a single type to use for parsing an entire file; i.e. all columns will be treated as the same type; useful for matrix-like data files\ntypes: a Vector or Dict of types to be used for column types; a Dict can map column index Int, or name Symbol or String to type for a column, i.e. Dict(1=>Float64) will set the first column as a Float64, Dict(:column1=>Float64) will set the column named column1 to Float64 and, Dict(\"column1\"=>Float64) will set the column1 to Float64; if a Vector if provided, it must match the # of columns provided or detected in header\ntypemap::Dict{Type, Type}: a mapping of a type that should be replaced in every instance with another type, i.e. Dict(Float64=>String) would change every detected Float64 column to be parsed as String; only \"standard\" types are allowed to be mapped to another type, i.e. Int64, Float64, Date, DateTime, Time, and Bool. If a column of one of those types is \"detected\", it will be mapped to the specified type.\npool::Union{Bool, Float64}=0.1: if true, all columns detected as String will be internally pooled; alternatively, the proportion of unique values below which String columns should be pooled (by default 0.1, meaning that if the # of unique strings in a column is under 10%, it will be pooled)\nlazystrings::Bool=false: avoid allocating full strings in string columns; returns a custom LazyStringVector array type that does not support mutable operations (e.g. push!, append!, or even setindex!). Calling copy(x) will materialize a full Vector{String}. Also note that each LazyStringVector holds a reference to the full input file buffer, so it won't be closed after parsing and trying to delete or modify the file may result in errors (particularly on windows) and generally has undefined behavior. Given these caveats, this setting can help avoid lots of string allocations in large files and lead to faster parsing times.\nstrict::Bool=false: whether invalid values should throw a parsing error or be replaced with missing\nsilencewarnings::Bool=false: if strict=false, whether invalid value warnings should be silenced\n\n\n\n\n\n","category":"type"},{"location":"#CSV.Chunks","page":"CSV.jl Documentation","title":"CSV.Chunks","text":"CSV.Chunks(source; tasks::Integer=Threads.nthreads(), kwargs...) => CSV.Chunks\n\nReturns a file \"chunk\" iterator. Accepts all the same inputs and keyword arguments as CSV.File, see those docs for explanations of each keyword argument.\n\nThe tasks keyword argument specifies how many chunks a file should be split up into, defaulting to  the # of threads available to Julia (i.e. JULIA_NUM_THREADS environment variable) or 8 if Julia is run single-threaded.\n\nEach iteration of CSV.Chunks produces the next chunk of a file as a CSV.File. While initial file metadata detection is done only once (to determine # of columns, column names, etc), each iteration does independent type inference on columns. This is significant as different chunks may end up with different column types than previous chunks as new values are encountered in the file. Note that, as with CSV.File, types may be passed manually via the type or types keyword arguments.\n\nThis functionality is new and thus considered experimental; please open an issue if you run into any problems/bugs.\n\n\n\n\n\n","category":"type"},{"location":"#CSV.Rows","page":"CSV.jl Documentation","title":"CSV.Rows","text":"CSV.Rows(source; kwargs...) => CSV.Rows\n\nRead a csv input returning a CSV.Rows object.\n\nThe source argument can be one of:\n\nfilename given as a string or FilePaths.jl type\nan AbstractVector{UInt8} like a byte buffer or codeunits(string)\nan IOBuffer\n\nTo read a csv file from a url, use the HTTP.jl package, where the HTTP.Response body can be passed like:\n\nf = CSV.Rows(HTTP.get(url).body)\n\nFor other IO or Cmd inputs, you can pass them like: f = CSV.Rows(read(obj)).\n\nWhile similar to CSV.File, CSV.Rows provides a slightly different interface, the tradeoffs including:\n\nVery minimal memory footprint; while iterating, only the current row values are buffered\nOnly provides row access via iteration; to access columns, one can stream the rows into a table type\nPerforms no type inference; each column/cell is essentially treated as Union{String, Missing}, users can utilize the performant Parsers.parse(T, str) to convert values to a more specific type if needed, or pass types upon construction using the type or types keyword arguments\n\nOpens the file and uses passed arguments to detect the number of columns, ***but not*** column types (column types default to String unless otherwise manually provided). The returned CSV.Rows object supports the Tables.jl interface and can iterate rows. Each row object supports propertynames, getproperty, and getindex to access individual row values. Note that duplicate column names will be detected and adjusted to ensure uniqueness (duplicate column name a will become a_1). For example, one could iterate over a csv file with column names a, b, and c by doing:\n\nfor row in CSV.Rows(file)\n    println(\"a=$(row.a), b=$(row.b), c=$(row.c)\")\nend\n\nSupported keyword arguments include:\n\nFile layout options:\nheader=1: the header argument can be an Int, indicating the row to parse for column names; or a Range, indicating a span of rows to be concatenated together as column names; or an entire Vector{Symbol} or Vector{String} to use as column names; if a file doesn't have column names, either provide them as a Vector, or set header=0 or header=false and column names will be auto-generated (Column1, Column2, etc.)\nnormalizenames=false: whether column names should be \"normalized\" into valid Julia identifier symbols; useful when iterating rows and accessing column values of a row via getproperty (e.g. row.col1)\ndatarow: an Int argument to specify the row where the data starts in the csv file; by default, the next row after the header row is used. If header=0, then the 1st row is assumed to be the start of data\nskipto::Int: similar to datarow, specifies the number of rows to skip before starting to read data\nlimit: an Int to indicate a limited number of rows to parse in a csv file; use in combination with skipto to read a specific, contiguous chunk within a file\ntranspose::Bool: read a csv file \"transposed\", i.e. each column is parsed as a row\ncomment: rows that begin with this String will be skipped while parsing\nignoreemptylines::Bool=false: whether empty rows/lines in a file should be ignored (if false, each column will be assigned missing for that empty row)\nParsing options:\nmissingstrings, missingstring: either a String, or Vector{String} to use as sentinel values that will be parsed as missing; by default, only an empty field (two consecutive delimiters) is considered missing\ndelim=',': a Char or String that indicates how columns are delimited in a file; if no argument is provided, parsing will try to detect the most consistent delimiter on the first 10 rows of the file\nignorerepeated::Bool=false: whether repeated (consecutive) delimiters should be ignored while parsing; useful for fixed-width files with delimiter padding between cells\nquotechar='\"', openquotechar, closequotechar: a Char (or different start and end characters) that indicate a quoted field which may contain textual delimiters or newline characters\nescapechar='\"': the Char used to escape quote characters in a quoted field\ndateformat::Union{String, Dates.DateFormat, Nothing}: a date format string to indicate how Date/DateTime columns are formatted for the entire file\ndecimal='.': a Char indicating how decimals are separated in floats, i.e. 3.14 used '.', or 3,14 uses a comma ','\ntruestrings, falsestrings: Vectors of Strings that indicate how true or false values are represented; by default only true and false are treated as Bool\nColumn Type Options:\ntype: a single type to use for parsing an entire file; i.e. all columns will be treated as the same type; useful for matrix-like data files\ntypes: a Vector or Dict of types to be used for column types; a Dict can map column index Int, or name Symbol or String to type for a column, i.e. Dict(1=>Float64) will set the first column as a Float64, Dict(:column1=>Float64) will set the column named column1 to Float64 and, Dict(\"column1\"=>Float64) will set the column1 to Float64; if a Vector if provided, it must match the # of columns provided or detected in header\ntypemap::Dict{Type, Type}: a mapping of a type that should be replaced in every instance with another type, i.e. Dict(Float64=>String) would change every detected Float64 column to be parsed as String\nlazystrings::Bool=true: avoid allocating full strings while parsing; accessing a string column will materialize the full String\nstrict::Bool=false: whether invalid values should throw a parsing error or be replaced with missing\nsilencewarnings::Bool=false: if strict=false, whether invalid value warnings should be silenced\nIteration options:\nreusebuffer=false: while iterating, whether a single row buffer should be allocated and reused on each iteration; only use if each row will be iterated once and not re-used (e.g. it's not safe to use this option if doing collect(CSV.Rows(file)) because only current iterated row is \"valid\")\n\n\n\n\n\n","category":"type"},{"location":"#CSV.write","page":"CSV.jl Documentation","title":"CSV.write","text":"CSV.write(file, table; kwargs...) => file\ntable |> CSV.write(file; kwargs...) => file\n\nWrite a Tables.jl interface input to a csv file, given as an IO argument or String/FilePaths.jl type representing the file name to write to. Alternatively, CSV.RowWriter creates a row iterator, producing a csv-formatted string for each row in an input table.\n\nSupported keyword arguments include:\n\ndelim::Union{Char, String}=',': a character or string to print out as the file's delimiter\nquotechar::Char='\"': ascii character to use for quoting text fields that may contain delimiters or newlines\nopenquotechar::Char: instead of quotechar, use openquotechar and closequotechar to support different starting and ending quote characters\nescapechar::Char='\"': ascii character used to escape quote characters in a text field\nmissingstring::String=\"\": string to print for missing values\ndateformat=Dates.default_format(T): the date format string to use for printing out Date & DateTime columns\nappend=false: whether to append writing to an existing file/IO, if true, it will not write column names by default\nwriteheader=!append: whether to write an initial row of delimited column names, not written by default if appending\nheader: pass a list of column names (Symbols or Strings) to use instead of the column names of the input table\nnewline='\\n': character or string to use to separate rows (lines in the csv file)\nquotestrings=false: whether to force all strings to be quoted or not\ndecimal='.': character to use as the decimal point when writing floating point numbers\ntransform=(col,val)->val: a function that is applied to every cell e.g. we can transform all nothing values to missing using (col, val) -> something(val, missing)\nbom=false: whether to write a UTF-8 BOM header (0xEF 0xBB 0xBF) or not\n\n\n\n\n\n","category":"function"},{"location":"#CSV.RowWriter","page":"CSV.jl Documentation","title":"CSV.RowWriter","text":"CSV.RowWriter(table; kwargs...)\n\nCreates an iterator that produces csv-formatted strings for each row in the input table.\n\nSupported keyword arguments include:\n\nbufsize::Int=2^22: The length of the buffer to use when writing each csv-formatted row; default 4MB; if a row is larger than the bufsize an error is thrown\ndelim::Union{Char, String}=',': a character or string to print out as the file's delimiter\nquotechar::Char='\"': ascii character to use for quoting text fields that may contain delimiters or newlines\nopenquotechar::Char: instead of quotechar, use openquotechar and closequotechar to support different starting and ending quote characters\nescapechar::Char='\"': ascii character used to escape quote characters in a text field\nmissingstring::String=\"\": string to print for missing values\ndateformat=Dates.default_format(T): the date format string to use for printing out Date & DateTime columns\nheader: pass a list of column names (Symbols or Strings) to use instead of the column names of the input table\nnewline='\\n': character or string to use to separate rows (lines in the csv file)\nquotestrings=false: whether to force all strings to be quoted or not\ndecimal='.': character to use as the decimal point when writing floating point numbers\ntransform=(col,val)->val: a function that is applied to every cell e.g. we can transform all nothing values to missing using (col, val) -> something(val, missing)\nbom=false: whether to write a UTF-8 BOM header (0xEF 0xBB 0xBF) or not\n\n\n\n\n\n","category":"type"},{"location":"#Examples-1","page":"CSV.jl Documentation","title":"Examples","text":"","category":"section"},{"location":"#Basic-1","page":"CSV.jl Documentation","title":"Basic","text":"","category":"section"},{"location":"#File-1","page":"CSV.jl Documentation","title":"File","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"col1,col2,col3,col4,col5,col6,col7,col8\n,1,1.0,1,one,2019-01-01,2019-01-01T00:00:00,true\n,2,2.0,2,two,2019-01-02,2019-01-02T00:00:00,false\n,3,3.0,3.14,three,2019-01-03,2019-01-03T00:00:00,true","category":"page"},{"location":"#Syntax-1","page":"CSV.jl Documentation","title":"Syntax","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"CSV.File(file)","category":"page"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"By default, CSV.File will automatically detect this file's delimiter ',', and the type of each column. By default, it treats \"empty fields\" as missing (the entire first column in this example). It also automatically handles promoting types, like the 4th column, where the first two values are Int, but the 3rd row has a Float64 value (3.14). The resulting column's type will be Float64. Parsing can detect Int64, Float64, Date, DateTime, Time and Bool types, with String as the fallback type for any column.","category":"page"},{"location":"#Auto-Delimiter-Detection-1","page":"CSV.jl Documentation","title":"Auto-Delimiter Detection","text":"","category":"section"},{"location":"#File-2","page":"CSV.jl Documentation","title":"File","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"col1|col2\n1|2\n3|4","category":"page"},{"location":"#Syntax-2","page":"CSV.jl Documentation","title":"Syntax","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"CSV.File(file)","category":"page"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"By default, CSV.File will try to detect a file's delimiter from the first 10 lines of the file; candidate delimiters include ',', '\\t', ' ', '|', ';', and ':'. If it can't auto-detect the delimiter, it will assume ','. If your file includes a different character or string delimiter, just pass delim=X where X is the character or string. For this file you could also do CSV.File(file; delim='|').","category":"page"},{"location":"#String-Delimiter-1","page":"CSV.jl Documentation","title":"String Delimiter","text":"","category":"section"},{"location":"#File-3","page":"CSV.jl Documentation","title":"File","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"col1::col2\n1::2\n3::4","category":"page"},{"location":"#Syntax-3","page":"CSV.jl Documentation","title":"Syntax","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"CSV.File(file; delim=\"::\")","category":"page"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"In this example, our file has fields separated by the string \"::\"; we can pass this as the delim keyword argument.","category":"page"},{"location":"#No-Header-1","page":"CSV.jl Documentation","title":"No Header","text":"","category":"section"},{"location":"#File-4","page":"CSV.jl Documentation","title":"File","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"1,2,3\n4,5,6\n7,8,9","category":"page"},{"location":"#Syntax-4","page":"CSV.jl Documentation","title":"Syntax","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"CSV.File(file; header=false)\nCSV.File(file; header=[\"col1\", \"col2\", \"col3\"])\nCSV.File(file; header=[:col1, :col2, :col3])","category":"page"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"In this file, there is no header row that contains column names. In the first option, we pass header=false, and column names will be generated like [:Column1, :Column2, :Column3]. In the two latter examples, we pass our own explicit column names, either as Strings or Symbols.","category":"page"},{"location":"#Normalize-Column-Names-1","page":"CSV.jl Documentation","title":"Normalize Column Names","text":"","category":"section"},{"location":"#File-5","page":"CSV.jl Documentation","title":"File","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"column one,column two, column three\n1,2,3\n4,5,6","category":"page"},{"location":"#Syntax-5","page":"CSV.jl Documentation","title":"Syntax","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"CSV.File(file; normalizenames=true)","category":"page"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"In this file, our column names have spaces in them. It can be convenient with a CSV.File or DataFrame to access entire columns via property access, e.g. if f = CSV.File(file) with column names like [:col1, :col2], I can access the entire first column of the file like f.col1, or for the second, f.col2. The call of f.col1 actually gets rewritten to the function call getproperty(f, :col1), which is the function implemented in CSV.jl that returns the col1 column from the file. When a column name is not a single atom Julia identifier, this is inconvient, because f.column one is not valid, so I would have to manually call getproperty(f, Symbol(\"column one\"). normalizenames=true comes to our rescue; it will replace invalid identifier characters with underscores to ensure each column is a valid Julia identifier, so for this file, we would end up with column names like [:column_one, :column_two]. You can call propertynames(f) on any CSV.File to see the parsed column names.","category":"page"},{"location":"#Datarow-1","page":"CSV.jl Documentation","title":"Datarow","text":"","category":"section"},{"location":"#File-6","page":"CSV.jl Documentation","title":"File","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"col1,col2,col3\nmetadata1,metadata2,metadata3\nextra1,extra2,extra3\n1,2,3\n4,5,6\n7,8,9","category":"page"},{"location":"#Syntax-6","page":"CSV.jl Documentation","title":"Syntax","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"CSV.File(file; datarow=4)\nCSV.File(file; skipto=4)","category":"page"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"This file has extra rows in between our header row col1,col2,col3 and the start of our data 1,2,3 on row 4. We can use the datarow or skipto keyword arguments to provide a row number where the \"data\" of our file begins.","category":"page"},{"location":"#Reading-Chunks-1","page":"CSV.jl Documentation","title":"Reading Chunks","text":"","category":"section"},{"location":"#File-7","page":"CSV.jl Documentation","title":"File","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"col1,col2,col3\n1,2,3\n4,5,6\n7,8,9\n10,11,12\n13,14,15\n16,17,18\n19,20,21","category":"page"},{"location":"#Syntax-7","page":"CSV.jl Documentation","title":"Syntax","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"CSV.File(file; limit=3)\nCSV.File(file; skipto=4, limit=1)\nCSV.File(file; skipto=7, footerskip=1)","category":"page"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"In this example, we desire to only read a subset of rows from the file. Using the limit, skipto, and footerskip keyword arguments, we can specify the exact rows we wish to parse.","category":"page"},{"location":"#Transposed-Data-1","page":"CSV.jl Documentation","title":"Transposed Data","text":"","category":"section"},{"location":"#File-8","page":"CSV.jl Documentation","title":"File","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"col1,1,2,3\ncol2,4,5,6\ncol3,7,8,9","category":"page"},{"location":"#Syntax-8","page":"CSV.jl Documentation","title":"Syntax","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"CSV.File(file; transpose=true)","category":"page"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"This file has the column names in the first column, and data that extends alongs rows horizontally. The data for col1 is all on the first row, similarly for col2 and its data on row 2. In this case, we wish to read the file \"transposed\", or treating rows as columns. By passing transpose=true, CSV.jl will read column names from the first column, and the data for each column from its corresponding row.","category":"page"},{"location":"#Commented-Rows-1","page":"CSV.jl Documentation","title":"Commented Rows","text":"","category":"section"},{"location":"#File-9","page":"CSV.jl Documentation","title":"File","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"col1,col2,col3\n# this row is commented and we'd like to ignore it while parsing\n1,2,3\n4,5,6","category":"page"},{"location":"#Syntax-9","page":"CSV.jl Documentation","title":"Syntax","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"CSV.File(file; comment=\"#\")\nCSV.File(file; datarow=3)","category":"page"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"This file has some rows that begin with the \"#\" string and denote breaks in the data for commentary. We wish to ignore these rows for purposes of reading data. We can pass comment=\"#\" and parsing will ignore any row that begins with this string. Alternatively, we can pass datarow=3 for this example specifically since there is only the one row to skip.","category":"page"},{"location":"#Missing-Strings-1","page":"CSV.jl Documentation","title":"Missing Strings","text":"","category":"section"},{"location":"#File-10","page":"CSV.jl Documentation","title":"File","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"code,age,score\n0,21,3.42\n1,42,6.55\n-999,81,NA\n-999,83,NA","category":"page"},{"location":"#Syntax-10","page":"CSV.jl Documentation","title":"Syntax","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"CSV.File(file; missingstring=\"-999\")\nCSV.File(file; missingstrings=[\"-999\", \"NA\"])","category":"page"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"In this file, our code column has two expected codes, 0 and 1, but also a few \"invalid\" codes, which are input as -999. We'd like to read the column as Int64, but treat the -999 values as \"missing\" values. By passing missingstring=\"-999\", we signal that this value should be replaced with the literal missing value builtin to the Julia language. We can then do things like dropmissing(f.col1) to ignore those values, for example. In the second recommended syntax, we also want to treat the NA values in our score column as missing, so we pass both strings like missingstrings=[\"-999\", \"NA\"].","category":"page"},{"location":"#Fixed-Width-Files-1","page":"CSV.jl Documentation","title":"Fixed Width Files","text":"","category":"section"},{"location":"#File-11","page":"CSV.jl Documentation","title":"File","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"col1    col2 col3\n123431  2    3421\n2355    346  7543","category":"page"},{"location":"#Syntax-11","page":"CSV.jl Documentation","title":"Syntax","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"CSV.File(file; delim=' ', ignorerepeated=true)","category":"page"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"This is an example of a \"fixed width\" file, where each column is the same number of characters away from each other on each row. This is different from a normal delimited file where each occurence of a delimiter indicates a separate field. With fixed width, however, fields are \"padded\" with extra delimiters (in this case ' ') so that each column is the same number of characters each time. In addition to our delim, we can pass ignorerepeated=true, which tells parsing that consecutive delimiters should be treated as a single delimiter.","category":"page"},{"location":"#Quoted-and-Escaped-Fields-1","page":"CSV.jl Documentation","title":"Quoted & Escaped Fields","text":"","category":"section"},{"location":"#File-12","page":"CSV.jl Documentation","title":"File","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"col1,col2\n\"quoted field with a delimiter , inside\",\"quoted field that contains a \\\\n newline and \"\"inner quotes\"\"\"\nunquoted field,unquoted field with \"inner quotes\"","category":"page"},{"location":"#Syntax-12","page":"CSV.jl Documentation","title":"Syntax","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"CSV.File(file; quotechar='\"', escapechar='\"')\nCSV.File(file; openquotechar='\"', closequotechar='\"', escapechar='\"')","category":"page"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"In this file, we have a few \"quoted\" fields, which means the field's value starts and ends with quotechar (or openquotechar and closequotechar, respectively). Quoted fields allow the field to contain characters that would otherwise be significant to parsing, such as delimiters or newline characters. When quoted, parsing will ignore these otherwise signficant characters until the closing quote character is found. For quoted fields that need to also include the quote character itself, an escape character is provided to tell parsing to ignore the next character when looking for a close quote character. In the syntax examples, the keyword arguments are passed explicitly, but these also happen to be the default values, so just doing CSV.File(file) would result in successful parsing.","category":"page"},{"location":"#DateFormat-1","page":"CSV.jl Documentation","title":"DateFormat","text":"","category":"section"},{"location":"#File-13","page":"CSV.jl Documentation","title":"File","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"code,date\n0,2019/01/01\n1,2019/01/02","category":"page"},{"location":"#Syntax-13","page":"CSV.jl Documentation","title":"Syntax","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"CSV.File(file; dateformat=\"yyyy/mm/dd\")","category":"page"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"In this file, our date column has dates that are formatted like yyyy/mm/dd. We can pass just such a string to the dateformat keyword argument to tell parsing to use it when looking for Date or DateTime columns. Note that currently, only a single dateformat string can be passed to parsing, meaning multiple columns with different date formats cannot all be parsed as Date/DateTime.","category":"page"},{"location":"#Custom-Decimal-Separator-1","page":"CSV.jl Documentation","title":"Custom Decimal Separator","text":"","category":"section"},{"location":"#File-14","page":"CSV.jl Documentation","title":"File","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"col1;col2;col3\n1,01;2,02;3,03\n4,04;5,05;6,06","category":"page"},{"location":"#Syntax-14","page":"CSV.jl Documentation","title":"Syntax","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"CSV.File(file; delim=';', decimal=',')","category":"page"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"In many places in the world, floating point number decimals are separated with a comma instead of a period (3,14 vs. 3.14). We can correctly parse these numbers by passing in the decimal=',' keyword argument. Note that we probably need to explicitly pass delim=';' in this case, since the parser will probably think that it detected ',' as the delimiter.","category":"page"},{"location":"#Custom-Bool-Strings-1","page":"CSV.jl Documentation","title":"Custom Bool Strings","text":"","category":"section"},{"location":"#File-15","page":"CSV.jl Documentation","title":"File","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"id,paid,attended\n0,T,TRUE\n1,F,TRUE\n2,T,FALSE\n3,F,FALSE","category":"page"},{"location":"#Syntax-15","page":"CSV.jl Documentation","title":"Syntax","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"CSV.File(file; truestrings=[\"T\", \"TRUE\"], falsestrings=[\"F\", \"FALSE\"])","category":"page"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"By default, parsing only considers the string values true and false as valid Bool values. To consider alternative values, we can pass a Vector{String} to the truestrings and falsestrings keyword arguments.","category":"page"},{"location":"#Matrix-like-Data-1","page":"CSV.jl Documentation","title":"Matrix-like Data","text":"","category":"section"},{"location":"#File-16","page":"CSV.jl Documentation","title":"File","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"1.0 0.0 0.0\n0.0 1.0 0.0\n0.0 0.0 1.0","category":"page"},{"location":"#Syntax-16","page":"CSV.jl Documentation","title":"Syntax","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"CSV.File(file; header=false)\nCSV.File(file; header=false, delim=' ', type=Float64)","category":"page"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"This file contains a 3x3 identity matrix of Float64. By default, parsing will detect the delimiter and type, but we can also explicitly pass delim= ' ' and type=Float64, which tells parsing to explicitly treat each column as Float64, without having to guess the type on its own.","category":"page"},{"location":"#Providing-Types-1","page":"CSV.jl Documentation","title":"Providing Types","text":"","category":"section"},{"location":"#File-17","page":"CSV.jl Documentation","title":"File","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"col1,col2,col3\n1,2,3\n4,5,invalid\n6,7,8","category":"page"},{"location":"#Syntax-17","page":"CSV.jl Documentation","title":"Syntax","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"CSV.File(file; types=Dict(3 => Int))\nCSV.File(file; types=Dict(:col3 => Int))\nCSV.File(file; types=Dict(\"col3\" => Int))\nCSV.File(file; types=[Int, Int, Int])\nCSV.File(file; types=[Int, Int, Int], silencewarnings=true)\nCSV.File(file; types=[Int, Int, Int], strict=true)","category":"page"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"In this file, our 3rd column has an invalid value on the 2nd row invalid. Let's imagine we'd still like to treat it as an Int column, and ignore the invalid value. The syntax examples provide several ways we can tell parsing to treat the 3rd column as Int, by referring to column index 3, or column name with Symbol or String. We can also provide an entire Vector of types for each column (and which needs to match the length of columns in the file). There are two additional keyword arguments that control parsing behavior; in the first 4 syntax examples, we would see a warning printed like \"warning: invalid Int64 value on row 2, column 3\". In the fifth example, passing silencewarnings=true will suppress this warning printing. In the last syntax example, passing strict=true will result in an error being thrown during parsing.","category":"page"},{"location":"#Typemap-1","page":"CSV.jl Documentation","title":"Typemap","text":"","category":"section"},{"location":"#File-18","page":"CSV.jl Documentation","title":"File","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"zipcode,score\n03494,9.9\n12345,6.7\n84044,3.4","category":"page"},{"location":"#Syntax-18","page":"CSV.jl Documentation","title":"Syntax","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"CSV.File(file; typemap=Dict(Int => String))\nCSV.File(file; types=Dict(:zipcode => String))","category":"page"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"In this file, we have U.S. zipcodes in the first column that we'd rather not treat as Int, but parsing will detect it as such. In the first syntax example, we pass typemap=Dict(Int => String), which tells parsing to treat any detected Int columns as String instead. In the second syntax example, we alternatively set the zipcode column type manually.","category":"page"},{"location":"#Pooled-Values-1","page":"CSV.jl Documentation","title":"Pooled Values","text":"","category":"section"},{"location":"#File-19","page":"CSV.jl Documentation","title":"File","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"id,code\nA18E9,AT\nBF392,GC\n93EBC,AT\n54EE1,AT\n8CD2E,GC","category":"page"},{"location":"#Syntax-19","page":"CSV.jl Documentation","title":"Syntax","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"CSV.File(file)\nCSV.File(file; pool=0.4)\nCSV.File(file; pool=0.6)","category":"page"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"In this file, we have an id column and a code column. There can be advantages with various DataFrame/table operations like joining and grouping when String values are \"pooled\", meaning each unique value is mapped to a UInt64. By default, pool=0.1, so string columns with low cardinality are pooled by default. Via the pool keyword argument, we can provide greater control: pool=0.4 means that if 40% or less of a column's values are unique, then it will be pooled.","category":"page"},{"location":"#Select/Drop-Columns-From-File-1","page":"CSV.jl Documentation","title":"Select/Drop Columns From File","text":"","category":"section"},{"location":"#File-20","page":"CSV.jl Documentation","title":"File","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"a,b,c\n1,2,3\n4,5,6\n7,8,9","category":"page"},{"location":"#Syntax-20","page":"CSV.jl Documentation","title":"Syntax","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"# select\nCSV.File(file; select=[1, 3])\nCSV.File(file; select=[:a, :c])\nCSV.File(file; select=[\"a\", \"c\"])\nCSV.File(file; select=[true, false, true])\nCSV.File(file; select=(i, nm) -> i in (1, 3))\n# drop\nCSV.File(file; drop=[2])\nCSV.File(file; drop=[:b])\nCSV.File(file; drop=[\"b\"])\nCSV.File(file; drop=[false, true, false])\nCSV.File(file; drop=(i, nm) -> i == 2)","category":"page"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"For this file, we have columns a, b, and c; we might only be interested in the data in columns a and c. Using the select or drop keyword arguments can allow efficiently choosing of columns from a file; columns not selected or dropped will be efficiently skipped while parsing, allowing for performance boosts. The arguments to select or drop can be one of: AbstractVector{Int} a collection of column indices; AbstractVector{Symbol} or AbstractVector{String} a collection of column names as Symbol or String; AbstractVector{Bool} a collection of Bool equal in length to the # of columns signaling whether a column should be selected or dropped; or a selector/drop function of the form (i, name) -> keep_or_drop::Bool, i.e. it takes a column index i and column name name and returns a Bool signaling whether a column should be selected or dropped.","category":"page"},{"location":"#Non-UTF-8-character-encodings-1","page":"CSV.jl Documentation","title":"Non-UTF-8 character encodings","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"Like Julia in general, CSV.jl interprets strings as being encoded in UTF-8. The StringEncodings package has to be used to read or write CSV files in other character encodings.","category":"page"},{"location":"#Example:-writing-to-and-reading-from-a-file-encoded-in-ISO-8859-1-1","page":"CSV.jl Documentation","title":"Example: writing to and reading from a file encoded in ISO-8859-1","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"using CSV, DataFrames, StringEncodings\n\n# writing to ISO-8859-1 file\na = DataFrame(a = [\"café\", \"noël\"])\nopen(\"a.csv\", enc\"ISO-8859-1\", \"w\") do io\n    CSV.write(io, a)\nend\n\n# reading from ISO-8859-1 file\nCSV.File(open(read, \"a.csv\", enc\"ISO-8859-1\")) |> DataFrame!\n\n# alternative: reencode data to UTF-8 in a new file and read from it\nopen(\"a2.csv\", \"w\") do io\n    foreach(x -> println(io, x), eachline(\"a.csv\", enc\"ISO-8859-1\"))\nend\nCSV.File(\"a2.csv\") |> DataFrame!","category":"page"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"Reencoding to a new file as in the last example above avoids storing an additional copy of the data in memory, which may be useful for large files that do not fit in RAM.","category":"page"},{"location":"#Reading-CSV-from-gzip-(.gz)-and-zip-files-1","page":"CSV.jl Documentation","title":"Reading CSV from gzip (.gz) and zip files","text":"","category":"section"},{"location":"#Example:-reading-from-a-gzip-(.gz)-file-1","page":"CSV.jl Documentation","title":"Example: reading from a gzip (.gz) file","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"using CSV, DataFrames, CodecZlib, Mmap\na = DataFrame(a = 1:3)\nCSV.write(\"a.csv\", a)\n\n# Windows users who do not have gzip available on the PATH should manually gzip the CSV\n;gzip a.csv\n\na_copy = CSV.File(transcode(GzipDecompressor, Mmap.mmap(\"a.csv.gz\"))) |> DataFrame!\n\na == a_copy # true; restored successfully\n","category":"page"},{"location":"#Example:-reading-from-a-zip-file-1","page":"CSV.jl Documentation","title":"Example: reading from a zip file","text":"","category":"section"},{"location":"#","page":"CSV.jl Documentation","title":"CSV.jl Documentation","text":"using ZipFile, CSV, DataFrames\n\na = DataFrame(a = 1:3)\nCSV.write(\"a.csv\", a)\n\n# zip the file; Windows users who do not have zip available on the PATH can manually zip the CSV\n# or write directly into the zip archive as shown below\n;zip a.zip a.csv\n\n# alternatively, write directly into the zip archive (without creating an unzipped csv file first)\nz = ZipFile.Writer(\"a2.zip\")\nf = ZipFile.addfile(z, \"a.csv\", method=ZipFile.Deflate)\na |> CSV.write(f)\nclose(z)\n\n# read file from zip archive\nz = ZipFile.Reader(\"a.zip\") # or \"a2.zip\"\n\n# identify the right file in zip\na_file_in_zip = filter(x->x.name == \"a.csv\", z.files)[1]\n\na_copy = CSV.File(a_file_in_zip) |> DataFrame!\n\na == a_copy","category":"page"}]
}
