<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reading · CSV.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">CSV.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li class="is-active"><a class="tocitem" href="reading.html">Reading</a><ul class="internal"><li><a class="tocitem" href="#input"><span><code>input</code></span></a></li><li><a class="tocitem" href="#header"><span><code>header</code></span></a></li><li><a class="tocitem" href="#normalizenames"><span><code>normalizenames</code></span></a></li><li><a class="tocitem" href="#skipto"><span><code>skipto</code></span></a></li><li><a class="tocitem" href="#footerskip"><span><code>footerskip</code></span></a></li><li><a class="tocitem" href="#transpose"><span><code>transpose</code></span></a></li><li><a class="tocitem" href="#comment"><span><code>comment</code></span></a></li><li><a class="tocitem" href="#ignoreemptyrows"><span><code>ignoreemptyrows</code></span></a></li><li><a class="tocitem" href="#select"><span><code>select</code> / <code>drop</code></span></a></li><li><a class="tocitem" href="#limit"><span><code>limit</code></span></a></li><li><a class="tocitem" href="#ntasks"><span><code>ntasks</code></span></a></li><li><a class="tocitem" href="#rows_to_check"><span><code>rows_to_check</code></span></a></li><li><a class="tocitem" href="#source"><span><code>source</code></span></a></li><li><a class="tocitem" href="#missingstring"><span><code>missingstring</code></span></a></li><li><a class="tocitem" href="#delim"><span><code>delim</code></span></a></li><li><a class="tocitem" href="#ignorerepeated"><span><code>ignorerepeated</code></span></a></li><li><a class="tocitem" href="#quoted"><span><code>quoted</code></span></a></li><li><a class="tocitem" href="#quotechar"><span><code>quotechar</code> / <code>openquotechar</code> / <code>closequotechar</code></span></a></li><li><a class="tocitem" href="#escapechar"><span><code>escapechar</code></span></a></li><li><a class="tocitem" href="#dateformat"><span><code>dateformat</code></span></a></li><li><a class="tocitem" href="#decimal"><span><code>decimal</code></span></a></li><li><a class="tocitem" href="#truestrings"><span><code>truestrings</code> / <code>falsestrings</code></span></a></li><li><a class="tocitem" href="#types"><span><code>types</code></span></a></li><li><a class="tocitem" href="#typemap"><span><code>typemap</code></span></a></li><li><a class="tocitem" href="#pool"><span><code>pool</code></span></a></li><li><a class="tocitem" href="#downcast"><span><code>downcast</code></span></a></li><li><a class="tocitem" href="#stringtype"><span><code>stringtype</code></span></a></li><li><a class="tocitem" href="#strict"><span><code>strict</code> / <code>silencewarnings</code> / <code>maxwarnings</code></span></a></li><li><a class="tocitem" href="#debug"><span><code>debug</code></span></a></li><li><a class="tocitem" href="#API-Reference"><span>API Reference</span></a></li><li><a class="tocitem" href="#Common-terms"><span>Common terms</span></a></li></ul></li><li><a class="tocitem" href="writing.html">Writing</a></li><li><a class="tocitem" href="examples.html">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="reading.html">Reading</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="reading.html">Reading</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaData/CSV.jl/blob/main/docs/src/reading.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reading"><a class="docs-heading-anchor" href="#Reading">Reading</a><a id="Reading-1"></a><a class="docs-heading-anchor-permalink" href="#Reading" title="Permalink"></a></h1><p>The format for this section will go through the various inputs/options supported by <a href="reading.html#CSV.File"><code>CSV.File</code></a>/<a href="reading.html#CSV.read"><code>CSV.read</code></a>, with notes about compatibility with the other reading functionality (<a href="reading.html#CSV.Rows"><code>CSV.Rows</code></a>, <a href="reading.html#CSV.Chunks"><code>CSV.Chunks</code></a>, etc.).</p><h2 id="input"><a class="docs-heading-anchor" href="#input"><code>input</code></a><a id="input-1"></a><a class="docs-heading-anchor-permalink" href="#input" title="Permalink"></a></h2><p>A required argument for reading. Input data should be ASCII or UTF-8 encoded text; for other text encodings, use the <a href="https://github.com/JuliaStrings/StringEncodings.jl">StringEncodings.jl</a> package to convert to UTF-8.</p><p>Any delimited input is ultimately converted to a byte buffer (<code>Vector{UInt8}</code>) for parsing/processing, so with that in mind, let&#39;s look at the various supported input types:</p><ul><li>File name as a <code>String</code> or <a href="https://juliahub.com/docs/FilePaths/PrU4O/0.8.0/"><code>FilePath</code></a>; parsing will call <code>Mmap.mmap(string(file))</code> to get a byte buffer to the file data. For gzip compressed inputs, like <code>file.gz</code>, the <a href="https://juliahub.com/docs/CodecZlib/1TI30/0.7.0/">CodecZlib.jl</a> package will be used to decompress the data to a temporary file first, then mmapped to a byte buffer. Decompression can also be done in memory by passing <code>buffer_in_memory=true</code>. Note that only gzip-compressed data is automatically decompressed; for other forms of compressed data, seek out the appropriate package to decompress and pass an IO or <code>Vector{UInt8}</code> of decompressed data as input.</li><li><code>Vector{UInt8}</code> or <code>SubArray{UInt8, 1, Vector{UInt8}}</code>: if you already have a byte buffer from wherever, you can just pass it in directly. If you have a csv-formatted string, you can pass it like <code>CSV.File(IOBuffer(str))</code></li><li><code>IO</code> or <code>Cmd</code>: you can pass an <code>IO</code> or <code>Cmd</code> directly, which will be consumed into a temporary file, then mmapped as a byte vector; to avoid a temp file and instead buffer data in memory, pass <code>buffer_in_memory=true</code>.</li><li>For files from the web, you can call <code>HTTP.get(url).body</code> to request the file, then access the data as a <code>Vector{UInt8}</code> from the <code>body</code> field, which can be passed directly for parsing. For Julia 1.6+, you can also use the <code>Downloads</code> stdlib, like <code>Downloads.download(url)</code> which can be passed to parsing</li></ul><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><ul><li><a href="examples.html#stringencodings">StringEncodings.jl example</a></li><li><a href="examples.html#vectorinputs">Vector of inputs example</a></li><li><a href="examples.html#gzipped_input">Gzip input</a></li><li><a href="examples.html#csv_string">Delimited data in a string</a></li><li><a href="examples.html#http">Data from the web</a></li><li><a href="examples.html#zip_example">Data in zip archive</a></li></ul><h2 id="header"><a class="docs-heading-anchor" href="#header"><code>header</code></a><a id="header-1"></a><a class="docs-heading-anchor-permalink" href="#header" title="Permalink"></a></h2><p>The <code>header</code> keyword argument controls how column names are treated when processing files. By default, it is assumed that the column names are the first row/line of the input, i.e. <code>header=1</code>. Alternative valid aguments for <code>header</code> include:</p><ul><li><code>Integer</code>, e.g. <code>header=2</code>: provide the row number as an <code>Integer</code> where the column names can be found</li><li><code>Bool</code>, e.g. <code>header=false</code>: no column names exist in the data; column names will be auto-generated depending on the # of columns, like <code>Column1</code>, <code>Column2</code>, etc.</li><li><code>Vector{String}</code> or <code>Vector{Symbol}</code>: manually provide column names as strings or symbols; should match the # of columns in the data. A copy of the <code>Vector</code> will be made and converted to <code>Vector{Symbol}</code></li><li><code>AbstractVector{&lt;:Integer}</code>: in rare cases, there may be multi-row headers; by passing a collection of row numbers, each row will be parsed and the values for each row will be concatenated to form the final column names</li></ul><h3 id="Examples-2"><a class="docs-heading-anchor" href="#Examples-2">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-2" title="Permalink"></a></h3><ul><li><a href="examples.html#second_row_header">Column names on second row</a></li><li><a href="examples.html#no_header">No column names in the data</a></li><li><a href="examples.html#manual_header">Manually provide column names</a></li><li><a href="examples.html#multi_row_header">Multi-row column names</a></li></ul><h2 id="normalizenames"><a class="docs-heading-anchor" href="#normalizenames"><code>normalizenames</code></a><a id="normalizenames-1"></a><a class="docs-heading-anchor-permalink" href="#normalizenames" title="Permalink"></a></h2><p>Controls whether column names will be &quot;normalized&quot; to valid Julia identifiers. By default, this is <code>false</code>. If <code>normalizenames=true</code>, then column names with spaces, or that start with numbers, will be adjusted with underscores to become valid Julia identifiers. This is useful when you want to access columns via dot-access or <code>getproperty</code>, like <code>file.col1</code>. The identifier that comes after the <code>.</code> must be valid, so spaces or identifiers starting with numbers aren&#39;t allowed.</p><h3 id="Examples-3"><a class="docs-heading-anchor" href="#Examples-3">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-3" title="Permalink"></a></h3><ul><li><a href="examples.html#normalize_header">Normalizing column names</a></li></ul><h2 id="skipto"><a class="docs-heading-anchor" href="#skipto"><code>skipto</code></a><a id="skipto-1"></a><a class="docs-heading-anchor-permalink" href="#skipto" title="Permalink"></a></h2><p>An <code>Integer</code> can be provided that specifies the row number where the data is located. By default, the row immediately following the header row is assumed to be the start of data. If <code>header=false</code>, or column names are provided manually as <code>Vector{String}</code> or <code>Vector{Symbol}</code>, the data is assumed to start on row 1, i.e. <code>skipto=1</code>.</p><h3 id="Examples-4"><a class="docs-heading-anchor" href="#Examples-4">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-4" title="Permalink"></a></h3><ul><li><a href="examples.html#skipto_example">Skip to specific row where data starts</a></li></ul><h2 id="footerskip"><a class="docs-heading-anchor" href="#footerskip"><code>footerskip</code></a><a id="footerskip-1"></a><a class="docs-heading-anchor-permalink" href="#footerskip" title="Permalink"></a></h2><p>An <code>Integer</code> argument specifying the number of rows to ignore at the end of a file. This works by the parser starting at the end of the file and parsing in reverse until <code>footerskip</code> # of rows have been parsed, then parsing the entire file, stopping at the newly adjusted &quot;end of file&quot;.</p><h3 id="Examples-5"><a class="docs-heading-anchor" href="#Examples-5">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-5" title="Permalink"></a></h3><ul><li><a href="examples.html#footerskip_example">Skipping trailing useless rows</a></li></ul><h2 id="transpose"><a class="docs-heading-anchor" href="#transpose"><code>transpose</code></a><a id="transpose-1"></a><a class="docs-heading-anchor-permalink" href="#transpose" title="Permalink"></a></h2><p>If <code>transpose=true</code> is passed, data will be read &quot;transposed&quot;, so each row will be parsed as a column, and each column in the data will be returned as a row. Useful when data is extremely wide (many columns), but you want to process it in a &quot;long&quot; format (many rows). Note that multithreaded parsing is not supported when parsing is transposed.</p><h3 id="Examples-6"><a class="docs-heading-anchor" href="#Examples-6">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-6" title="Permalink"></a></h3><ul><li><a href="examples.html#transpose_example">Reading transposed data</a></li></ul><h2 id="comment"><a class="docs-heading-anchor" href="#comment"><code>comment</code></a><a id="comment-1"></a><a class="docs-heading-anchor-permalink" href="#comment" title="Permalink"></a></h2><p>A <code>String</code> argument that, when encountered at the start of a row while parsing, will cause the row to be skipped. When providing <code>header</code>, <code>skipto</code>, or <code>footerskip</code> arguments, it should be noted that commented rows, while ignored, still count as &quot;rows&quot; when skipping to a specific row. In this way, you can visually identify, for example, that column names are on row 6, and pass <code>header=6</code>, even if row 5 is a commented row and will be ignored.</p><h3 id="Examples-7"><a class="docs-heading-anchor" href="#Examples-7">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-7" title="Permalink"></a></h3><ul><li><a href="examples.html#comment_example">Ignoring commented rows</a></li></ul><h2 id="ignoreemptyrows"><a class="docs-heading-anchor" href="#ignoreemptyrows"><code>ignoreemptyrows</code></a><a id="ignoreemptyrows-1"></a><a class="docs-heading-anchor-permalink" href="#ignoreemptyrows" title="Permalink"></a></h2><p>This argument specifies whether &quot;empty rows&quot;, where consecutive <a href="reading.html#newlines">newlines</a> are parsed, should be ignored or not. By default, they are. If <code>ignoreemptyrows=false</code>, then for an empty row, all existing columns will have <code>missing</code> assigned to their value for that row. Similar to commented rows, empty rows also still count as &quot;rows&quot; when any of the <code>header</code>, <code>skipto</code>, or <code>footerskip</code> arguments are provided.</p><h3 id="Examples-8"><a class="docs-heading-anchor" href="#Examples-8">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-8" title="Permalink"></a></h3><ul><li><a href="examples.html#ignoreemptyrows_example">Ignoring empty rows</a></li></ul><h2 id="select"><a class="docs-heading-anchor" href="#select"><code>select</code> / <code>drop</code></a><a id="select-1"></a><a class="docs-heading-anchor-permalink" href="#select" title="Permalink"></a></h2><p>Arguments that control which columns from the input data will actually be parsed and available after processing. <code>select</code> controls which columns <em>will</em> be accessible after parsing while <code>drop</code> controls which columns to <em>ignore</em>. Either argument can be provided as a vector of <code>Integer</code>, <code>String</code>, or <code>Symbol</code>, specifing the column numbers or names to include/exclude. A vector of <code>Bool</code> matching the number of columns in the input data can also be provided, where each element specifies whether the corresponding column should be included/excluded. Finally, these arguments can also be given as boolean functions, of the form <code>(i, name) -&gt; Bool</code>, where each column number and name will be given as arguments and the result of the function will determine if the column will be included/excluded.</p><h3 id="Examples-9"><a class="docs-heading-anchor" href="#Examples-9">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-9" title="Permalink"></a></h3><ul><li><a href="examples.html#select_example">Including/excluding columns</a></li></ul><h2 id="limit"><a class="docs-heading-anchor" href="#limit"><code>limit</code></a><a id="limit-1"></a><a class="docs-heading-anchor-permalink" href="#limit" title="Permalink"></a></h2><p>An <code>Integer</code> argument to specify the number of rows that should be read from the data. Can be used in conjunction with <a href="reading.html#skipto"><code>skipto</code></a> to read contiguous chunks of a file. Note that with multithreaded parsing (when the data is deemed large enough), it can be difficult for parsing to determine the exact # of rows to limit to, so it may or may not return exactly <code>limit</code> number of rows. To ensure an exact limit on larger files, also pass <code>ntasks=1</code> to force single-threaded parsing.</p><h3 id="Examples-10"><a class="docs-heading-anchor" href="#Examples-10">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-10" title="Permalink"></a></h3><ul><li><a href="examples.html#limit_example">Limiting number of rows from data</a></li></ul><h2 id="ntasks"><a class="docs-heading-anchor" href="#ntasks"><code>ntasks</code></a><a id="ntasks-1"></a><a class="docs-heading-anchor-permalink" href="#ntasks" title="Permalink"></a></h2><p>NOTE: not applicable to <code>CSV.Rows</code></p><p>For large enough data inputs, <code>ntasks</code> controls the number of multithreaded tasks used to concurrently parse the data. By default, it uses <code>Threads.nthreads()</code>, which is the number of threads the julia process was started with, either via <code>julia -t N</code> or the <code>JULIA_NUM_THREADS</code> environment variable. To avoid multithreaded parsing, even on large files, pass <code>ntasks=1</code>. This argument is only applicable to <code>CSV.File</code>, not <code>CSV.Rows</code>. For <code>CSV.Chunks</code>, it controls the total number of chunk iterations a large file will be split up into for parsing.</p><h2 id="rows_to_check"><a class="docs-heading-anchor" href="#rows_to_check"><code>rows_to_check</code></a><a id="rows_to_check-1"></a><a class="docs-heading-anchor-permalink" href="#rows_to_check" title="Permalink"></a></h2><p>NOTE: not applicable to <code>CSV.Rows</code></p><p>When input data is large enough, parsing will attempt to &quot;chunk&quot; up the data for multithreaded tasks to parse concurrently. To chunk up the data, it is split up into even chunks, then initial parsers attempt to identify the correct start of the first row of that chunk. Once the start of the chunk&#39;s first row is found, each parser will check <code>rows_to_check</code> number of rows to ensure the expected number of columns are present.</p><h2 id="source"><a class="docs-heading-anchor" href="#source"><code>source</code></a><a id="source-1"></a><a class="docs-heading-anchor-permalink" href="#source" title="Permalink"></a></h2><p>NOTE: only applicable to vector of inputs passed to <code>CSV.File</code></p><p>A <code>Symbol</code>, <code>String</code>, or <code>Pair</code> of <code>Symbol</code> or <code>String</code> to <code>Vector</code>. As a single <code>Symbol</code> or <code>String</code>, provides the column name that will be added to the parsed columns, the values of the column will be the input &quot;name&quot; (usually file name) of the input from whence the value was parsed. As a <code>Pair</code>, the 2nd part of the pair should be a <code>Vector</code> of values matching the length of the # of inputs, where each value will be used instead of the input name for that inputs values in the auto-added column.</p><h2 id="missingstring"><a class="docs-heading-anchor" href="#missingstring"><code>missingstring</code></a><a id="missingstring-1"></a><a class="docs-heading-anchor-permalink" href="#missingstring" title="Permalink"></a></h2><p>Argument to control how <code>missing</code> values are handled while parsing input data. The default is <code>missingstring=&quot;&quot;</code>, which means two consecutive delimiters, like <code>,,</code>, will result in a cell being set as a <code>missing</code> value. Otherwise, you can pass a single string to use as a &quot;sentinel&quot;, like <code>missingstring=&quot;NA&quot;</code>, or a vector of strings, where <em>each</em> will be checked for when parsing, like <code>missingstring=[&quot;NA&quot;, &quot;NAN&quot;, &quot;NULL&quot;]</code>, and if <em>any</em> match, the cell will be set to <code>missing</code>. By passing <code>missingstring=nothing</code>, no <code>missing</code> values will be checked for while parsing.</p><h3 id="Examples-11"><a class="docs-heading-anchor" href="#Examples-11">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-11" title="Permalink"></a></h3><ul><li><a href="examples.html#missing_string_example">Specifying custom missing strings</a></li></ul><h2 id="delim"><a class="docs-heading-anchor" href="#delim"><code>delim</code></a><a id="delim-1"></a><a class="docs-heading-anchor-permalink" href="#delim" title="Permalink"></a></h2><p>A <code>Char</code> or <code>String</code> argument that parsing looks for in the data input that separates distinct columns on each row. If no argument is provided (the default), parsing will try to detect the most consistent delimiter on the first 10 rows of the input, falling back to a single comma (<code>,</code>) if no other delimiter can be detected consistently.</p><h3 id="Examples-12"><a class="docs-heading-anchor" href="#Examples-12">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-12" title="Permalink"></a></h3><ul><li><a href="examples.html#string_delim">String delimiter</a></li></ul><h2 id="ignorerepeated"><a class="docs-heading-anchor" href="#ignorerepeated"><code>ignorerepeated</code></a><a id="ignorerepeated-1"></a><a class="docs-heading-anchor-permalink" href="#ignorerepeated" title="Permalink"></a></h2><p>A <code>Bool</code> argument, default <code>false</code>, that, if set to <code>true</code>, will cause parsing to ignore any number of consecutive delimiters between columns. This option can often be used to accurately parse fixed-width data inputs, where columns are delimited with a fixed number of delimiters, or a row is fixed-width and columns may have a variable number of delimiters between them based on the length of cell values.</p><h3 id="Examples-13"><a class="docs-heading-anchor" href="#Examples-13">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-13" title="Permalink"></a></h3><ul><li><a href="examples.html#ignorerepeated_example">Fixed width files</a></li></ul><h2 id="quoted"><a class="docs-heading-anchor" href="#quoted"><code>quoted</code></a><a id="quoted-1"></a><a class="docs-heading-anchor-permalink" href="#quoted" title="Permalink"></a></h2><p>A <code>Bool</code> argument that controls whether parsing will check for opening/closing quote characters at the start/end of cells. Default <code>true</code>. If you happen to know a file has no quoted cells, it can simplify parsing to pass <code>quoted=false</code>, so parsing avoids treating the <code>quotechar</code> or <code>openquotechar</code>/<code>closequotechar</code> arguments specially.</p><h3 id="Examples-14"><a class="docs-heading-anchor" href="#Examples-14">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-14" title="Permalink"></a></h3><ul><li><a href="examples.html#quoted_example">Turning off quoted cell parsing</a></li></ul><h2 id="quotechar"><a class="docs-heading-anchor" href="#quotechar"><code>quotechar</code> / <code>openquotechar</code> / <code>closequotechar</code></a><a id="quotechar-1"></a><a class="docs-heading-anchor-permalink" href="#quotechar" title="Permalink"></a></h2><p>An ASCII <code>Char</code> argument (or arguments if both <code>openquotechar</code> and <code>closequotechar</code> are provided) that parsing uses to handle &quot;quoted&quot; cells. If a cell string value contains the <a href="reading.html#delim">delim</a> argument, or a newline, it should start and end with <code>quotechar</code>, or start with <code>openquotechar</code> and end with <code>closequotechar</code> so parsing knows to treat the <code>delim</code> or newline as part of the cell <em>value</em> instead of as significant parsing characters. If the <code>quotechar</code> or <code>closequotechar</code> characters also need to appear in the cell value, they should be properly escaped via the <a href="reading.html#escapechar">escapechar</a> argument.</p><h3 id="Examples-15"><a class="docs-heading-anchor" href="#Examples-15">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-15" title="Permalink"></a></h3><ul><li><a href="examples.html#quotechar_example">Quoted &amp; escaped fields</a></li></ul><h2 id="escapechar"><a class="docs-heading-anchor" href="#escapechar"><code>escapechar</code></a><a id="escapechar-1"></a><a class="docs-heading-anchor-permalink" href="#escapechar" title="Permalink"></a></h2><p>An ASCII <code>Char</code> argument that parsing uses when parsing quoted cells and the <code>quotechar</code> or <code>closequotechar</code> characters appear in a cell string value. If the <code>escapechar</code> character is encountered inside a quoted cell, it will be &quot;skipped&quot;, and the following character will not be checked for parsing significance, but just treated as another character in the value of the cell. Note the <code>escapechar</code> is <em>not</em> included in the value of the cell, but is ignored completely.</p><h2 id="dateformat"><a class="docs-heading-anchor" href="#dateformat"><code>dateformat</code></a><a id="dateformat-1"></a><a class="docs-heading-anchor-permalink" href="#dateformat" title="Permalink"></a></h2><p>A <code>String</code> or <code>AbstractDict</code> argument that controls how parsing detects datetime values in the data input. As a single <code>String</code> (or <code>DateFormat</code>) argument, the same format will be applied to <em>all</em> columns in the file. For columns without type information provided otherwise, parsing will use the provided format string to check if the cell is parseable and if so, will attempt to parse the entire column as the datetime type (<code>Time</code>, <code>Date</code>, or <code>DateTime</code>). By default, if no <code>dateformat</code> argument is explicitly provided, parsing will try to detect any of <code>Time</code>, <code>Date</code>, or <code>DateTime</code> types following the standard <code>Dates.ISOTimeFormat</code>, <code>Dates.ISODateFormat</code>, or <code>Dates.ISODateTimeFormat</code> formats, respectively. If a datetime type is provided for a column, (see the <a href="reading.html#types">types</a> argument), then the <code>dateformat</code> format string needs to match the format of values in that column, otherwise, a warning will be emitted and the value will be replaced with a <code>missing</code> value (this behavior is also configurable via the <a href="reading.html#strict">strict</a> and <a href="reading.html#strict">silencewarnings</a> arguments). If an <code>AbstractDict</code> is provided, different <code>dateformat</code> strings can be provided for specific columns; the provided dict can map either an <code>Integer</code> for column number or a <code>String</code>, <code>Symbol</code> or <code>Regex</code> for column name to the dateformat string that should be used for that column. Columns not mapped in the dict argument will use the default format strings mentioned above.</p><h3 id="Examples-16"><a class="docs-heading-anchor" href="#Examples-16">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-16" title="Permalink"></a></h3><ul><li><a href="examples.html#dateformat_example">DateFormat</a></li></ul><h2 id="decimal"><a class="docs-heading-anchor" href="#decimal"><code>decimal</code></a><a id="decimal-1"></a><a class="docs-heading-anchor-permalink" href="#decimal" title="Permalink"></a></h2><p>An ASCII <code>Char</code> argument that is used when parsing float values that indicates where the fractional portion of the float value begins. i.e. for the truncated values of pie <code>3.14</code>, the <code>&#39;.&#39;</code> character separates the <code>3</code> and <code>14</code> values, whereas for <code>3,14</code> (common European notation), the <code>&#39;,&#39;</code> character separates the fractional portion. By default, <code>decimal=&#39;.&#39;</code>.</p><h3 id="Examples-17"><a class="docs-heading-anchor" href="#Examples-17">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-17" title="Permalink"></a></h3><ul><li><a href="examples.html#decimal_example">Custom decimal separator</a></li></ul><h2 id="truestrings"><a class="docs-heading-anchor" href="#truestrings"><code>truestrings</code> / <code>falsestrings</code></a><a id="truestrings-1"></a><a class="docs-heading-anchor-permalink" href="#truestrings" title="Permalink"></a></h2><p>These arguments can be provided as <code>Vector{String}</code> to specify custom values that should be treated as the <code>Bool</code> <code>true</code>/<code>false</code> values for all the columns of a data input. By default, <code>[&quot;true&quot;, &quot;True&quot;, &quot;TRUE&quot;, &quot;T&quot;, &quot;1&quot;]</code> string values are used to detect <code>true</code> values, and <code>[&quot;false&quot;, &quot;False&quot;, &quot;FALSE&quot;, &quot;F&quot;, &quot;0&quot;]</code> string values are used to detect <code>false</code> values. Note that even though <code>&quot;1&quot;</code> and <code>&quot;0&quot;</code> <em>can</em> be used to parse <code>true</code>/<code>false</code> values, in terms of <em>auto</em> detecting column types, those values will be parsed as <code>Int64</code> first, instead of <code>Bool</code>. To instead parse those values as <code>Bool</code>s for a column, you can manually provide that column&#39;s type as <code>Bool</code> (see the <a href="reading.html#types">type</a> argument).</p><h3 id="Examples-18"><a class="docs-heading-anchor" href="#Examples-18">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-18" title="Permalink"></a></h3><ul><li><a href="examples.html#truestrings_example">Custom bool strings</a></li></ul><h2 id="types"><a class="docs-heading-anchor" href="#types"><code>types</code></a><a id="types-1"></a><a class="docs-heading-anchor-permalink" href="#types" title="Permalink"></a></h2><p>Argument to control the types of columns that get parsed in the data input. Can be provided as a single <code>Type</code>, an <code>AbstractVector</code> of types, an <code>AbstractDict</code>, or a function.</p><ul><li>If a single type is provided, like <code>types=Float64</code>, then <em>all</em> columns in the data input will be parsed as <code>Float64</code>. If a column&#39;s value isn&#39;t a valid <code>Float64</code> value, then a warning will be emitted, unless <code>silencewarnings=false</code> is passed, then no warning will be printed. However, if <code>strict=true</code> is passed, then an error will be thrown instead, regarldess of the <code>silencewarnings</code> argument.</li><li>If a <code>AbstractVector{Type}</code> is provided, then the length of the vector should match the number of columns in the data input, and each element gives the type of the corresponding column in order.</li><li>If an <code>AbstractDict</code>, then specific columns can have their column type specified with the key of the dict being an <code>Integer</code> for column number, or <code>String</code> or <code>Symbol</code> for column name or <code>Regex</code> matching column names, and the dict value being the column type. Unspecified columns will have their column type auto-detected while parsing.</li><li>If a function, then it should be of the form <code>(i, name) -&gt; Union{T, Nothing}</code>, and will be applied to each detected column during initial parsing. Returning <code>nothing</code> from the function will result in the column&#39;s type being automatically detected during parsing.</li></ul><p>By default <code>types=nothing</code>, which means all column types in the data input will be detected while parsing. Note that it isn&#39;t necessary to pass <code>types=Union{Float64, Missing}</code> if the data input contains <code>missing</code> values. Parsing will detect <code>missing</code> values if present, and promote any manually provided column types from the singular (<code>Float65</code>) to the missing equivalent (<code>Union{Float64, Missing}</code>) automatically. Standard types will be auto-detected in the following order when not otherwise specified:  <code>Int64</code>, <code>Float64</code>, <code>Date</code>, <code>DateTime</code>, <code>Time</code>, <code>Bool</code>, <code>String</code>.</p><p>Non-standard types can be provided, like <code>Dec64</code> from the DecFP.jl package, but must support the <code>Base.tryparse(T, str)</code> function for parsing a value from a string. This allows, for example, easily defining a custom type, like <code>struct Float64Array; values::Vector{Float64}; end</code>, as long as a corresponding <code>Base.tryparse</code> definition is defined, like <code>Base.tryparse(::Type{Float64Array}, str) = Float64Array(map(x -&gt; parse(Float64, x), split(str, &#39;;&#39;)))</code>, where a single cell in the data input is like <code>1.23;4.56;7.89</code>.</p><p>Note that the default <a href="reading.html#stringtype">stringtype</a> can be overridden by providing a column&#39;s type manually, like <code>CSV.File(source; types=Dict(1 =&gt; String), stringtype=PosLenString)</code>, where the first column will be parsed as a <code>String</code>, while any other string columns will have the <code>PosLenString</code> type.</p><h3 id="Examples-19"><a class="docs-heading-anchor" href="#Examples-19">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-19" title="Permalink"></a></h3><ul><li><a href="examples.html#matrix_example">Matrix-like Data</a></li><li><a href="examples.html#types_example">Providing types</a></li></ul><h2 id="typemap"><a class="docs-heading-anchor" href="#typemap"><code>typemap</code></a><a id="typemap-1"></a><a class="docs-heading-anchor-permalink" href="#typemap" title="Permalink"></a></h2><p>An <code>AbstractDict{Type, Type}</code> argument that allows replacing a non-<code>String</code> standard type with another type when a column&#39;s type is auto-detected. Most commonly, this would be used to force all numeric columns to be <code>Float64</code>, like <code>typemap=IdDict(Int64 =&gt; Float64)</code>, which would cause any columns detected as <code>Int64</code> to be parsed as <code>Float64</code> instead. Another common case would be wanting all columns of a specific type to be parsed as strings instead, like <code>typemap=IdDict(Date =&gt; String)</code>, which will cause any columns detected as <code>Date</code> to be parsed as <code>String</code> instead.</p><h3 id="Examples-20"><a class="docs-heading-anchor" href="#Examples-20">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-20" title="Permalink"></a></h3><ul><li><a href="examples.html#typemap_example">Typemap</a></li></ul><h2 id="pool"><a class="docs-heading-anchor" href="#pool"><code>pool</code></a><a id="pool-1"></a><a class="docs-heading-anchor-permalink" href="#pool" title="Permalink"></a></h2><p>Argument that controls whether columns will be returned as <code>PooledArray</code>s. Can be provided as a <code>Bool</code>, <code>Float64</code>, <code>Tuple{Float64, Int}</code>, vector, dict, or a function of the form <code>(i, name) -&gt; Union{Bool, Real,  Tuple{Float64, Int}, Nothing}</code>. As a <code>Bool</code>, controls absolutely whether a column will be pooled or not; if passed as a single <code>Bool</code> argument like <code>pool=true</code>, then all string columns will be pooled, regardless of cardinality. When passed as a <code>Float64</code>, the value should be between <code>0.0</code> and <code>1.0</code> to indicate the threshold under which the % of unique values found in the column will result in the column being pooled. For example, if <code>pool=0.1</code>, then all string columns with a unique value % less than 10% will be returned as <code>PooledArray</code>, while other string columns will be normal string vectors. If <code>pool</code> is provided as a tuple, like <code>(0.2, 500)</code>, the first tuple element is the same as a single <code>Float64</code> value, which represents the % cardinality allowed. The second tuple element is an upper limit on the # of unique values allowed to pool the column. So the example, <code>pool=(0.2, 500)</code> means if a String column has less than or equal to 500 unique values <em>and</em> the # of unique values is less than 20% of total # of values, it will be pooled, otherwise, it won&#39;t. As mentioned, when the <code>pool</code> argument is a single <code>Bool</code>, <code>Real</code>, or <code>Tuple{Float64, Int}</code>, only string columns will be considered for pooling. When a vector or dict is provided, the pooling for any column can be provided as a <code>Bool</code>, <code>Float64</code>, or <code>Tuple{Float64, Int}</code>. Similar to the <a href="reading.html#types">types</a> argument, providing a vector to <code>pool</code> should have an element for each column in the data input, while a dict argument can map column number/name to <code>Bool</code>, <code>Float64</code>, or <code>Tuple{Float64, Int}</code> for specific columns. Unspecified columns will not be pooled when the argument is a dict.</p><h3 id="Examples-21"><a class="docs-heading-anchor" href="#Examples-21">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-21" title="Permalink"></a></h3><ul><li><a href="examples.html#pool_example">Pooled values</a></li><li><a href="examples.html#nonstring_pool_example">Non-string column pooling</a></li><li><a href="examples.html#pool_absolute_threshold">Pool with absolute threshold</a></li></ul><h2 id="downcast"><a class="docs-heading-anchor" href="#downcast"><code>downcast</code></a><a id="downcast-1"></a><a class="docs-heading-anchor-permalink" href="#downcast" title="Permalink"></a></h2><p>A <code>Bool</code> argument that controls whether <code>Integer</code> detected column types will be &quot;shrunk&quot; to the smallest possible integer type. Argument is <code>false</code> by default. Only applies to auto-detected column types; i.e. if a column type is provided manually as <code>Int64</code>, it will not be shrunk. Useful for shrinking the overall memory footprint of parsed data, though care should be taken when processing the results as Julia by default as <a href="https://en.wikipedia.org/wiki/Integer_overflow">integer overflow</a> behavior, which is increasingly likely the smaller the integer type.</p><h2 id="stringtype"><a class="docs-heading-anchor" href="#stringtype"><code>stringtype</code></a><a id="stringtype-1"></a><a class="docs-heading-anchor-permalink" href="#stringtype" title="Permalink"></a></h2><p>An argument that controls the precise type of string columns. Supported values are <code>InlineString</code> (the default), <code>PosLenString</code>, or <code>String</code>. The various string types are aimed at being mostly transparent to most users. In certain workflows, however, it can be advantageous to be more specific. Here&#39;s a quick rundown of the possible options:</p><ul><li><code>InlineString</code>: a set of fixed-width, stack-allocated primitive types. Can take memory pressure off the GC because they aren&#39;t reference types/on the heap. For very large files with string columns that have a fairly low variance in string length, this can provide much better GC interaction than <code>String</code>. When string length has a high variance, it can lead to lots of &quot;wasted space&quot;, since an entire column will be promoted to the smallest InlineString type that fits the longest string value. For small strings, that can mean a lot of wasted space when they&#39;re promoted to a high fixed-width.</li><li><code>PosLenString</code>: results in columns returned as <code>PosLenStringVector</code> (or <code>ChainedVector{PosLenStringVector}</code> for the multithreaded case), which holds a reference to the original input data, and acts as one large &quot;view&quot; vector into the original data where each cell begins/ends. Can result in the smallest memory footprint for string columns. <code>PosLenStringVector</code>, however, does not support traditional mutable operations like regular <code>Vector</code>s, like <code>push!</code>, <code>append!</code>, or <code>deleteat!</code>.</li><li><code>String</code>: each string must be heap-allocated, which can result in higher GC pressure in very large files. But columns are returned as normal <code>Vector{String}</code> (or <code>ChainedVector{Vector{String}}</code>), which can be processed normally, including any mutating operations.</li></ul><h2 id="strict"><a class="docs-heading-anchor" href="#strict"><code>strict</code> / <code>silencewarnings</code> / <code>maxwarnings</code></a><a id="strict-1"></a><a class="docs-heading-anchor-permalink" href="#strict" title="Permalink"></a></h2><p>Arguments that control error behavior when invalid values are encountered while parsing. Only applicable when types are provided manually by the user via the <a href="reading.html#types">types</a> argument. If a column type is manually provided, but an invalid value is encountered, the default behavior is to set the value for that cell to <code>missing</code>, emit a warning (i.e. <code>silencewarnings=false</code> and <code>strict=false</code>), but only up to 100 total warnings and then they&#39;ll be silenced (i.e. <code>maxwarnings=100</code>). If <code>strict=true</code>, then invalid values will result in an error being thrown instead of any warnings emitted.</p><h2 id="debug"><a class="docs-heading-anchor" href="#debug"><code>debug</code></a><a id="debug-1"></a><a class="docs-heading-anchor-permalink" href="#debug" title="Permalink"></a></h2><p>A <code>Bool</code> argument that controls the printing of extra &quot;debug&quot; information while parsing. Can be useful if parsing doesn&#39;t produce the expected result or a bug is suspected in parsing somehow.</p><h2 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CSV.read" href="#CSV.read"><code>CSV.read</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>CSV.read(source, sink::T; kwargs...)</code> =&gt; T</p><p>Read and parses a delimited file or files, materializing directly using the <code>sink</code> function. Allows avoiding excessive copies of columns for certain sinks like <code>DataFrame</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; using CSV, DataFrames

julia&gt; path = tempname();

julia&gt; write(path, &quot;a,b,c\n1,2,3&quot;);

julia&gt; CSV.read(path, DataFrame)
1×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; CSV.read(path, DataFrame; header=false)
2×3 DataFrame
 Row │ Column1  Column2  Column3
     │ String1  String1  String1
─────┼───────────────────────────
   1 │ a        b        c
   2 │ 1        2        3</code></pre><p><strong>Arguments</strong></p><p><strong>File layout options:</strong></p><ul><li><code>header=1</code>: how column names should be determined; if given as an <code>Integer</code>, indicates the row to parse for column names; as an <code>AbstractVector{&lt;:Integer}</code>, indicates a set of rows to be concatenated together as column names; <code>Vector{Symbol}</code> or <code>Vector{String}</code> give column names explicitly (should match # of columns in dataset); if a dataset doesn&#39;t have column names, either provide them as a <code>Vector</code>, or set <code>header=0</code> or <code>header=false</code> and column names will be auto-generated (<code>Column1</code>, <code>Column2</code>, etc.). Note that if a row number header and <code>comment</code> or <code>ignoreemptyrows</code> are provided, the header row will be the first non-commented/non-empty row <em>after</em> the row number, meaning if the provided row number is a commented row, the header row will actually be the next non-commented row.</li><li><code>normalizenames::Bool=false</code>: whether column names should be &quot;normalized&quot; into valid Julia identifier symbols; useful when using the <code>tbl.col1</code> <code>getproperty</code> syntax or iterating rows and accessing column values of a row via <code>getproperty</code> (e.g. <code>row.col1</code>)</li><li><code>skipto::Integer</code>: specifies the row where the data starts in the csv file; by default, the next row after the <code>header</code> row(s) is used. If <code>header=0</code>, then the 1st row is assumed to be the start of data; providing a <code>skipto</code> argument does <em>not</em> affect the <code>header</code> argument. Note that if a row number <code>skipto</code> and <code>comment</code> or <code>ignoreemptyrows</code> are provided, the data row will be the first non-commented/non-empty row <em>after</em> the row number, meaning if the provided row number is a commented row, the data row will actually be the next non-commented row.</li><li><code>footerskip::Integer</code>: number of rows at the end of a file to skip parsing.  Do note that commented rows (see the <code>comment</code> keyword argument) <em>do not</em> count towards the row number provided for <code>footerskip</code>, they are completely ignored by the parser</li><li><code>transpose::Bool</code>: read a csv file &quot;transposed&quot;, i.e. each column is parsed as a row</li><li><code>comment::String</code>: string that will cause rows that begin with it to be skipped while parsing. Note that if a row number header or <code>skipto</code> and <code>comment</code> are provided, the header/data row will be the first non-commented/non-empty row <em>after</em> the row number, meaning if the provided row number is a commented row, the header/data row will actually be the next non-commented row.</li><li><code>ignoreemptyrows::Bool=true</code>: whether empty rows in a file should be ignored (if <code>false</code>, each column will be assigned <code>missing</code> for that empty row)</li><li><code>select</code>: an <code>AbstractVector</code> of <code>Integer</code>, <code>Symbol</code>, <code>String</code>, or <code>Bool</code>, or a &quot;selector&quot; function of the form <code>(i, name) -&gt; keep::Bool</code>; only columns in the collection or for which the selector function returns <code>true</code> will be parsed and accessible in the resulting <code>CSV.File</code>. Invalid values in <code>select</code> are ignored.</li><li><code>drop</code>: inverse of <code>select</code>; an <code>AbstractVector</code> of <code>Integer</code>, <code>Symbol</code>, <code>String</code>, or <code>Bool</code>, or a &quot;drop&quot; function of the form <code>(i, name) -&gt; drop::Bool</code>; columns in the collection or for which the drop function returns <code>true</code> will ignored in the resulting <code>CSV.File</code>. Invalid values in <code>drop</code> are ignored.</li><li><code>limit</code>: an <code>Integer</code> to indicate a limited number of rows to parse in a csv file; use in combination with <code>skipto</code> to read a specific, contiguous chunk within a file; note for large files when multiple threads are used for parsing, the <code>limit</code> argument may not result in an exact # of rows parsed; use <code>threaded=false</code> to ensure an exact limit if necessary</li><li><code>buffer_in_memory</code>: a <code>Bool</code>, default <code>false</code>, which controls whether a <code>Cmd</code>, <code>IO</code>, or gzipped source will be read/decompressed in memory vs. using a temporary file.</li><li><code>ntasks::Integer=Threads.nthreads()</code>: [not applicable to <code>CSV.Rows</code>] for multithreaded parsed files, this controls the number of tasks spawned to read a file in concurrent chunks; defaults to the # of threads Julia was started with (i.e. <code>JULIA_NUM_THREADS</code> environment variable or <code>julia -t N</code>); setting <code>ntasks=1</code> will avoid any calls to <code>Threads.@spawn</code> and just read the file serially on the main thread; a single thread will also be used for smaller files by default (&lt; 5_000 cells)</li><li><code>rows_to_check::Integer=30</code>: [not applicable to <code>CSV.Rows</code>] a multithreaded parsed file will be split up into <code>ntasks</code> # of equal chunks; <code>rows_to_check</code> controls the # of rows are checked to ensure parsing correctly found valid rows; for certain files with very large quoted text fields, <code>lines_to_check</code> may need to be higher (10, 30, etc.) to ensure parsing correctly finds these rows</li><li><code>source</code>: [only applicable for vector of inputs to <code>CSV.File</code>] a <code>Symbol</code>, <code>String</code>, or <code>Pair</code> of <code>Symbol</code> or <code>String</code> to <code>Vector</code>. As a single <code>Symbol</code> or <code>String</code>, provides the column name that will be added to the parsed columns, the values of the column will be the input &quot;name&quot; (usually file name) of the input from whence the value was parsed. As a <code>Pair</code>, the 2nd part of the pair should be a <code>Vector</code> of values matching the length of the # of inputs, where each value will be used instead of the input name for that inputs values in the auto-added column.</li></ul><p><strong>Parsing options:</strong></p><ul><li><code>missingstring</code>: either a <code>nothing</code>, <code>String</code>, or <code>Vector{String}</code> to use as sentinel values that will be parsed as <code>missing</code>; if <code>nothing</code> is passed, no sentinel/missing values will be parsed; by default, <code>missingstring=&quot;&quot;</code>, which means only an empty field (two consecutive delimiters) is considered <code>missing</code></li><li><code>delim=&#39;,&#39;</code>: a <code>Char</code> or <code>String</code> that indicates how columns are delimited in a file; if no argument is provided, parsing will try to detect the most consistent delimiter on the first 10 rows of the file</li><li><code>ignorerepeated::Bool=false</code>: whether repeated (consecutive/sequential) delimiters should be ignored while parsing; useful for fixed-width files with delimiter padding between cells</li><li><code>quoted::Bool=true</code>: whether parsing should check for <code>quotechar</code> at the start/end of cells</li><li><code>quotechar=&#39;&quot;&#39;</code>, <code>openquotechar</code>, <code>closequotechar</code>: a <code>Char</code> (or different start and end characters) that indicate a quoted field which may contain textual delimiters or newline characters</li><li><code>escapechar=&#39;&quot;&#39;</code>: the <code>Char</code> used to escape quote characters in a quoted field</li><li><code>dateformat::Union{String, Dates.DateFormat, Nothing, AbstractDict}</code>: a date format string to indicate how Date/DateTime columns are formatted for the entire file; if given as an <code>AbstractDict</code>, date format strings to indicate how the Date/DateTime columns corresponding to the keys are formatted. The Dict can map column index <code>Int</code>, or name <code>Symbol</code> or <code>String</code> to the format string for that column.</li><li><code>decimal=&#39;.&#39;</code>: a <code>Char</code> indicating how decimals are separated in floats, i.e. <code>3.14</code> uses <code>&#39;.&#39;</code>, or <code>3,14</code> uses a comma <code>&#39;,&#39;</code></li><li><code>truestrings</code>, <code>falsestrings</code>: <code>Vector{String}</code>s that indicate how <code>true</code> or <code>false</code> values are represented; by default <code>&quot;true&quot;, &quot;True&quot;, &quot;TRUE&quot;, &quot;T&quot;, &quot;1&quot;</code> are used to detect <code>true</code> and <code>&quot;false&quot;, &quot;False&quot;, &quot;FALSE&quot;, &quot;F&quot;, &quot;0&quot;</code> are used to detect <code>false</code>; note that columns with only <code>1</code> and <code>0</code> values will default to <code>Int64</code> column type unless explicitly requested to be <code>Bool</code> via <code>types</code> keyword argument</li><li><code>stripwhitespace=false</code>: if true, leading and trailing whitespace are stripped from string values, including column names</li></ul><p><strong>Column Type Options:</strong></p><ul><li><code>types</code>: a single <code>Type</code>, <code>AbstractVector</code> or <code>AbstractDict</code> of types, or a function of the form <code>(i, name) -&gt; Union{T, Nothing}</code> to be used for column types; if a single <code>Type</code> is provided, <em>all</em> columns will be parsed with that single type; an <code>AbstractDict</code> can map column index <code>Integer</code>, or name <code>Symbol</code> or <code>String</code> to type for a column, i.e. <code>Dict(1=&gt;Float64)</code> will set the first column as a <code>Float64</code>, <code>Dict(:column1=&gt;Float64)</code> will set the column named <code>column1</code> to <code>Float64</code> and, <code>Dict(&quot;column1&quot;=&gt;Float64)</code> will set the <code>column1</code> to <code>Float64</code>; if a <code>Vector</code> is provided, it must match the # of columns provided or detected in <code>header</code>. If a function is provided, it takes a column index and name as arguments, and should return the desired column type for the column, or <code>nothing</code> to signal the column&#39;s type should be detected while parsing.</li><li><code>typemap::IdDict{Type, Type}</code>: a mapping of a type that should be replaced in every instance with another type, i.e. <code>Dict(Float64=&gt;String)</code> would change every detected <code>Float64</code> column to be parsed as <code>String</code>; only &quot;standard&quot; types are allowed to be mapped to another type, i.e. <code>Int64</code>, <code>Float64</code>, <code>Date</code>, <code>DateTime</code>, <code>Time</code>, and <code>Bool</code>. If a column of one of those types is &quot;detected&quot;, it will be mapped to the specified type.</li><li><code>pool::Union{Bool, Real, AbstractVector, AbstractDict, Function, Tuple{Float64, Int}}=(0.2, 500)</code>: [not supported by <code>CSV.Rows</code>] controls whether columns will be built as <code>PooledArray</code>; if <code>true</code>, all columns detected as <code>String</code> will be pooled; alternatively, the proportion of unique values below which <code>String</code> columns should be pooled (meaning that if the # of unique strings in a column is under 25%, <code>pool=0.25</code>, it will be pooled). If provided as a <code>Tuple{Float64, Int}</code> like <code>(0.2, 500)</code>, it represents the percent cardinality threshold as the 1st tuple element (<code>0.2</code>), and an upper limit for the # of unique values (<code>500</code>), under which the column will be pooled; this is the default (<code>pool=(0.2, 500)</code>). If an <code>AbstractVector</code>, each element should be <code>Bool</code>, <code>Real</code>, or <code>Tuple{Float64, Int}</code> and the # of elements should match the # of columns in the dataset; if an <code>AbstractDict</code>, a <code>Bool</code>, <code>Real</code>, or <code>Tuple{Float64, Int}</code> value can be provided for individual columns where the dict key is given as column index <code>Integer</code>, or column name as <code>Symbol</code> or <code>String</code>. If a function is provided, it should take a column index and name as 2 arguments, and return a <code>Bool</code>, <code>Real</code>, <code>Tuple{Float64, Int}</code>, or <code>nothing</code> for each column.</li><li><code>downcast::Bool=false</code>: controls whether columns detected as <code>Int64</code> will be &quot;downcast&quot; to the smallest possible integer type like <code>Int8</code>, <code>Int16</code>, <code>Int32</code>, etc.</li><li><code>stringtype=InlineStrings.InlineString</code>: controls how detected string columns will ultimately be returned; default is <code>InlineString</code>, which stores string data in a fixed-size primitive type that helps avoid excessive heap memory usage; if a column has values longer than 32 bytes, it will default to <code>String</code>. If <code>String</code> is passed, all string columns will just be normal <code>String</code> values. If <code>PosLenString</code> is passed, string columns will be returned as <code>PosLenStringVector</code>, which is a special &quot;lazy&quot; <code>AbstractVector</code> that acts as a &quot;view&quot; into the original file data. This can lead to the most efficient parsing times, but note that the &quot;view&quot; nature of <code>PosLenStringVector</code> makes it read-only, so operations like <code>push!</code>, <code>append!</code>, or <code>setindex!</code> are not supported. It also keeps a reference to the entire input dataset source, so trying to modify or delete the underlying file, for example, may fail</li><li><code>strict::Bool=false</code>: whether invalid values should throw a parsing error or be replaced with <code>missing</code></li><li><code>silencewarnings::Bool=false</code>: if <code>strict=false</code>, whether invalid value warnings should be silenced</li><li><code>maxwarnings::Int=100</code>: if more than <code>maxwarnings</code> number of warnings are printed while parsing, further warnings will be silenced by default; for multithreaded parsing, each parsing task will print up to <code>maxwarnings</code></li><li><code>debug::Bool=false</code>: passing <code>true</code> will result in many informational prints while a dataset is parsed; can be useful when reporting issues or figuring out what is going on internally while a dataset is parsed</li><li><code>validate::Bool=true</code>: whether or not to validate that columns specified in the <code>types</code>, <code>dateformat</code> and <code>pool</code> keywords are actually found in the data. If <code>false</code> no validation is done, meaning no error will be thrown if <code>types</code>/<code>dateformat</code>/<code>pool</code> specify settings for columns not actually found in the data.</li></ul><p><strong>Iteration options:</strong></p><ul><li><code>reusebuffer=false</code>: [only supported by <code>CSV.Rows</code>] while iterating, whether a single row buffer should be allocated and reused on each iteration; only use if each row will be iterated once and not re-used (e.g. it&#39;s not safe to use this option if doing <code>collect(CSV.Rows(file))</code> because only current iterated row is &quot;valid&quot;)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/CSV.jl/blob/390a7d3ef15971b580d1c9ba746caae22f8db343/src/CSV.jl#L81-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CSV.File" href="#CSV.File"><code>CSV.File</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CSV.File(input; kwargs...) =&gt; CSV.File</code></pre><p>Read a UTF-8 CSV input and return a <code>CSV.File</code> object, which is like a lightweight table/dataframe, allowing dot-access to columns and iterating rows. Satisfies the Tables.jl interface, so can be passed to any valid sink, yet to avoid unnecessary copies of data, use <code>CSV.read(input, sink; kwargs...)</code> instead if the <code>CSV.File</code> intermediate object isn&#39;t needed.</p><p>The <a href="reading.html#input"><code>input</code></a> argument can be one of:</p><ul><li>filename given as a string or FilePaths.jl type</li><li>a <code>Vector{UInt8}</code> or <code>SubArray{UInt8, 1, Vector{UInt8}}</code> byte buffer</li><li>a <code>CodeUnits</code> object, which wraps a <code>String</code>, like <code>codeunits(str)</code></li><li>a csv-formatted string can also be passed like <code>IOBuffer(str)</code></li><li>a <code>Cmd</code> or other <code>IO</code></li><li>a gzipped file (or gzipped data in any of the above), which will automatically be decompressed for parsing</li><li>a <code>Vector</code> of any of the above, which will parse and vertically concatenate each source, returning a single, &quot;long&quot; <code>CSV.File</code></li></ul><p>To read a csv file from a url, use the Downloads.jl stdlib or HTTP.jl package, where the resulting downloaded tempfile or <code>HTTP.Response</code> body can be passed like:</p><pre><code class="language-julia hljs">using Downloads, CSV
f = CSV.File(Downloads.download(url))

# or

using HTTP, CSV
f = CSV.File(HTTP.get(url).body)</code></pre><p>Opens the file or files and uses passed arguments to detect the number of columns and column types, unless column types are provided manually via the <code>types</code> keyword argument. Note that passing column types manually can slightly increase performance for each column type provided (column types can be given as a <code>Vector</code> for all columns, or specified per column via name or index in a <code>Dict</code>).</p><p>When a <code>Vector</code> of inputs is provided, the column names and types of each separate file/input must match to be vertically concatenated. Separate threads will be used to parse each input, which will each parse their input using just the single thread. The results of all threads are then vertically concatenated using <code>ChainedVector</code>s to lazily concatenate each thread&#39;s columns.</p><p>For text encodings other than UTF-8, load the <a href="https://github.com/JuliaStrings/StringEncodings.jl">StringEncodings.jl</a> package and call e.g. <code>CSV.File(open(read, input, enc&quot;ISO-8859-1&quot;))</code>.</p><p>The returned <code>CSV.File</code> object supports the <a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a> interface and can iterate <code>CSV.Row</code>s. <code>CSV.Row</code> supports <code>propertynames</code> and <code>getproperty</code> to access individual row values. <code>CSV.File</code> also supports entire column access like a <code>DataFrame</code> via direct property access on the file object, like <code>f = CSV.File(file); f.col1</code>. Or by getindex access with column names, like <code>f[:col1]</code> or <code>f[&quot;col1&quot;]</code>. The returned columns are <code>AbstractArray</code> subtypes, including: <code>SentinelVector</code> (for integers), regular <code>Vector</code>, <code>PooledVector</code> for pooled columns, <code>MissingVector</code> for columns of all <code>missing</code> values, <code>PosLenStringVector</code> when <code>stringtype=PosLenString</code> is passed, and <code>ChainedVector</code> will chain one of the previous array types together for data inputs that use multiple threads to parse (each thread parses a single &quot;chain&quot; of the input). Note that duplicate column names will be detected and adjusted to ensure uniqueness (duplicate column name <code>a</code> will become <code>a_1</code>). For example, one could iterate over a csv file with column names <code>a</code>, <code>b</code>, and <code>c</code> by doing:</p><pre><code class="language-julia hljs">for row in CSV.File(file)
    println(&quot;a=$(row.a), b=$(row.b), c=$(row.c)&quot;)
end</code></pre><p>By supporting the Tables.jl interface, a <code>CSV.File</code> can also be a table input to any other table sink function. Like:</p><pre><code class="language-julia hljs"># materialize a csv file as a DataFrame, copying columns from CSV.File
df = CSV.File(file) |&gt; DataFrame

# to avoid making a copy of parsed columns, use CSV.read
df = CSV.read(file, DataFrame)

# load a csv file directly into an sqlite database table
db = SQLite.DB()
tbl = CSV.File(file) |&gt; SQLite.load!(db, &quot;sqlite_table&quot;)</code></pre><p><strong>Arguments</strong></p><p><strong>File layout options:</strong></p><ul><li><code>header=1</code>: how column names should be determined; if given as an <code>Integer</code>, indicates the row to parse for column names; as an <code>AbstractVector{&lt;:Integer}</code>, indicates a set of rows to be concatenated together as column names; <code>Vector{Symbol}</code> or <code>Vector{String}</code> give column names explicitly (should match # of columns in dataset); if a dataset doesn&#39;t have column names, either provide them as a <code>Vector</code>, or set <code>header=0</code> or <code>header=false</code> and column names will be auto-generated (<code>Column1</code>, <code>Column2</code>, etc.). Note that if a row number header and <code>comment</code> or <code>ignoreemptyrows</code> are provided, the header row will be the first non-commented/non-empty row <em>after</em> the row number, meaning if the provided row number is a commented row, the header row will actually be the next non-commented row.</li><li><code>normalizenames::Bool=false</code>: whether column names should be &quot;normalized&quot; into valid Julia identifier symbols; useful when using the <code>tbl.col1</code> <code>getproperty</code> syntax or iterating rows and accessing column values of a row via <code>getproperty</code> (e.g. <code>row.col1</code>)</li><li><code>skipto::Integer</code>: specifies the row where the data starts in the csv file; by default, the next row after the <code>header</code> row(s) is used. If <code>header=0</code>, then the 1st row is assumed to be the start of data; providing a <code>skipto</code> argument does <em>not</em> affect the <code>header</code> argument. Note that if a row number <code>skipto</code> and <code>comment</code> or <code>ignoreemptyrows</code> are provided, the data row will be the first non-commented/non-empty row <em>after</em> the row number, meaning if the provided row number is a commented row, the data row will actually be the next non-commented row.</li><li><code>footerskip::Integer</code>: number of rows at the end of a file to skip parsing.  Do note that commented rows (see the <code>comment</code> keyword argument) <em>do not</em> count towards the row number provided for <code>footerskip</code>, they are completely ignored by the parser</li><li><code>transpose::Bool</code>: read a csv file &quot;transposed&quot;, i.e. each column is parsed as a row</li><li><code>comment::String</code>: string that will cause rows that begin with it to be skipped while parsing. Note that if a row number header or <code>skipto</code> and <code>comment</code> are provided, the header/data row will be the first non-commented/non-empty row <em>after</em> the row number, meaning if the provided row number is a commented row, the header/data row will actually be the next non-commented row.</li><li><code>ignoreemptyrows::Bool=true</code>: whether empty rows in a file should be ignored (if <code>false</code>, each column will be assigned <code>missing</code> for that empty row)</li><li><code>select</code>: an <code>AbstractVector</code> of <code>Integer</code>, <code>Symbol</code>, <code>String</code>, or <code>Bool</code>, or a &quot;selector&quot; function of the form <code>(i, name) -&gt; keep::Bool</code>; only columns in the collection or for which the selector function returns <code>true</code> will be parsed and accessible in the resulting <code>CSV.File</code>. Invalid values in <code>select</code> are ignored.</li><li><code>drop</code>: inverse of <code>select</code>; an <code>AbstractVector</code> of <code>Integer</code>, <code>Symbol</code>, <code>String</code>, or <code>Bool</code>, or a &quot;drop&quot; function of the form <code>(i, name) -&gt; drop::Bool</code>; columns in the collection or for which the drop function returns <code>true</code> will ignored in the resulting <code>CSV.File</code>. Invalid values in <code>drop</code> are ignored.</li><li><code>limit</code>: an <code>Integer</code> to indicate a limited number of rows to parse in a csv file; use in combination with <code>skipto</code> to read a specific, contiguous chunk within a file; note for large files when multiple threads are used for parsing, the <code>limit</code> argument may not result in an exact # of rows parsed; use <code>threaded=false</code> to ensure an exact limit if necessary</li><li><code>buffer_in_memory</code>: a <code>Bool</code>, default <code>false</code>, which controls whether a <code>Cmd</code>, <code>IO</code>, or gzipped source will be read/decompressed in memory vs. using a temporary file.</li><li><code>ntasks::Integer=Threads.nthreads()</code>: [not applicable to <code>CSV.Rows</code>] for multithreaded parsed files, this controls the number of tasks spawned to read a file in concurrent chunks; defaults to the # of threads Julia was started with (i.e. <code>JULIA_NUM_THREADS</code> environment variable or <code>julia -t N</code>); setting <code>ntasks=1</code> will avoid any calls to <code>Threads.@spawn</code> and just read the file serially on the main thread; a single thread will also be used for smaller files by default (&lt; 5_000 cells)</li><li><code>rows_to_check::Integer=30</code>: [not applicable to <code>CSV.Rows</code>] a multithreaded parsed file will be split up into <code>ntasks</code> # of equal chunks; <code>rows_to_check</code> controls the # of rows are checked to ensure parsing correctly found valid rows; for certain files with very large quoted text fields, <code>lines_to_check</code> may need to be higher (10, 30, etc.) to ensure parsing correctly finds these rows</li><li><code>source</code>: [only applicable for vector of inputs to <code>CSV.File</code>] a <code>Symbol</code>, <code>String</code>, or <code>Pair</code> of <code>Symbol</code> or <code>String</code> to <code>Vector</code>. As a single <code>Symbol</code> or <code>String</code>, provides the column name that will be added to the parsed columns, the values of the column will be the input &quot;name&quot; (usually file name) of the input from whence the value was parsed. As a <code>Pair</code>, the 2nd part of the pair should be a <code>Vector</code> of values matching the length of the # of inputs, where each value will be used instead of the input name for that inputs values in the auto-added column.</li></ul><p><strong>Parsing options:</strong></p><ul><li><code>missingstring</code>: either a <code>nothing</code>, <code>String</code>, or <code>Vector{String}</code> to use as sentinel values that will be parsed as <code>missing</code>; if <code>nothing</code> is passed, no sentinel/missing values will be parsed; by default, <code>missingstring=&quot;&quot;</code>, which means only an empty field (two consecutive delimiters) is considered <code>missing</code></li><li><code>delim=&#39;,&#39;</code>: a <code>Char</code> or <code>String</code> that indicates how columns are delimited in a file; if no argument is provided, parsing will try to detect the most consistent delimiter on the first 10 rows of the file</li><li><code>ignorerepeated::Bool=false</code>: whether repeated (consecutive/sequential) delimiters should be ignored while parsing; useful for fixed-width files with delimiter padding between cells</li><li><code>quoted::Bool=true</code>: whether parsing should check for <code>quotechar</code> at the start/end of cells</li><li><code>quotechar=&#39;&quot;&#39;</code>, <code>openquotechar</code>, <code>closequotechar</code>: a <code>Char</code> (or different start and end characters) that indicate a quoted field which may contain textual delimiters or newline characters</li><li><code>escapechar=&#39;&quot;&#39;</code>: the <code>Char</code> used to escape quote characters in a quoted field</li><li><code>dateformat::Union{String, Dates.DateFormat, Nothing, AbstractDict}</code>: a date format string to indicate how Date/DateTime columns are formatted for the entire file; if given as an <code>AbstractDict</code>, date format strings to indicate how the Date/DateTime columns corresponding to the keys are formatted. The Dict can map column index <code>Int</code>, or name <code>Symbol</code> or <code>String</code> to the format string for that column.</li><li><code>decimal=&#39;.&#39;</code>: a <code>Char</code> indicating how decimals are separated in floats, i.e. <code>3.14</code> uses <code>&#39;.&#39;</code>, or <code>3,14</code> uses a comma <code>&#39;,&#39;</code></li><li><code>truestrings</code>, <code>falsestrings</code>: <code>Vector{String}</code>s that indicate how <code>true</code> or <code>false</code> values are represented; by default <code>&quot;true&quot;, &quot;True&quot;, &quot;TRUE&quot;, &quot;T&quot;, &quot;1&quot;</code> are used to detect <code>true</code> and <code>&quot;false&quot;, &quot;False&quot;, &quot;FALSE&quot;, &quot;F&quot;, &quot;0&quot;</code> are used to detect <code>false</code>; note that columns with only <code>1</code> and <code>0</code> values will default to <code>Int64</code> column type unless explicitly requested to be <code>Bool</code> via <code>types</code> keyword argument</li><li><code>stripwhitespace=false</code>: if true, leading and trailing whitespace are stripped from string values, including column names</li></ul><p><strong>Column Type Options:</strong></p><ul><li><code>types</code>: a single <code>Type</code>, <code>AbstractVector</code> or <code>AbstractDict</code> of types, or a function of the form <code>(i, name) -&gt; Union{T, Nothing}</code> to be used for column types; if a single <code>Type</code> is provided, <em>all</em> columns will be parsed with that single type; an <code>AbstractDict</code> can map column index <code>Integer</code>, or name <code>Symbol</code> or <code>String</code> to type for a column, i.e. <code>Dict(1=&gt;Float64)</code> will set the first column as a <code>Float64</code>, <code>Dict(:column1=&gt;Float64)</code> will set the column named <code>column1</code> to <code>Float64</code> and, <code>Dict(&quot;column1&quot;=&gt;Float64)</code> will set the <code>column1</code> to <code>Float64</code>; if a <code>Vector</code> is provided, it must match the # of columns provided or detected in <code>header</code>. If a function is provided, it takes a column index and name as arguments, and should return the desired column type for the column, or <code>nothing</code> to signal the column&#39;s type should be detected while parsing.</li><li><code>typemap::IdDict{Type, Type}</code>: a mapping of a type that should be replaced in every instance with another type, i.e. <code>Dict(Float64=&gt;String)</code> would change every detected <code>Float64</code> column to be parsed as <code>String</code>; only &quot;standard&quot; types are allowed to be mapped to another type, i.e. <code>Int64</code>, <code>Float64</code>, <code>Date</code>, <code>DateTime</code>, <code>Time</code>, and <code>Bool</code>. If a column of one of those types is &quot;detected&quot;, it will be mapped to the specified type.</li><li><code>pool::Union{Bool, Real, AbstractVector, AbstractDict, Function, Tuple{Float64, Int}}=(0.2, 500)</code>: [not supported by <code>CSV.Rows</code>] controls whether columns will be built as <code>PooledArray</code>; if <code>true</code>, all columns detected as <code>String</code> will be pooled; alternatively, the proportion of unique values below which <code>String</code> columns should be pooled (meaning that if the # of unique strings in a column is under 25%, <code>pool=0.25</code>, it will be pooled). If provided as a <code>Tuple{Float64, Int}</code> like <code>(0.2, 500)</code>, it represents the percent cardinality threshold as the 1st tuple element (<code>0.2</code>), and an upper limit for the # of unique values (<code>500</code>), under which the column will be pooled; this is the default (<code>pool=(0.2, 500)</code>). If an <code>AbstractVector</code>, each element should be <code>Bool</code>, <code>Real</code>, or <code>Tuple{Float64, Int}</code> and the # of elements should match the # of columns in the dataset; if an <code>AbstractDict</code>, a <code>Bool</code>, <code>Real</code>, or <code>Tuple{Float64, Int}</code> value can be provided for individual columns where the dict key is given as column index <code>Integer</code>, or column name as <code>Symbol</code> or <code>String</code>. If a function is provided, it should take a column index and name as 2 arguments, and return a <code>Bool</code>, <code>Real</code>, <code>Tuple{Float64, Int}</code>, or <code>nothing</code> for each column.</li><li><code>downcast::Bool=false</code>: controls whether columns detected as <code>Int64</code> will be &quot;downcast&quot; to the smallest possible integer type like <code>Int8</code>, <code>Int16</code>, <code>Int32</code>, etc.</li><li><code>stringtype=InlineStrings.InlineString</code>: controls how detected string columns will ultimately be returned; default is <code>InlineString</code>, which stores string data in a fixed-size primitive type that helps avoid excessive heap memory usage; if a column has values longer than 32 bytes, it will default to <code>String</code>. If <code>String</code> is passed, all string columns will just be normal <code>String</code> values. If <code>PosLenString</code> is passed, string columns will be returned as <code>PosLenStringVector</code>, which is a special &quot;lazy&quot; <code>AbstractVector</code> that acts as a &quot;view&quot; into the original file data. This can lead to the most efficient parsing times, but note that the &quot;view&quot; nature of <code>PosLenStringVector</code> makes it read-only, so operations like <code>push!</code>, <code>append!</code>, or <code>setindex!</code> are not supported. It also keeps a reference to the entire input dataset source, so trying to modify or delete the underlying file, for example, may fail</li><li><code>strict::Bool=false</code>: whether invalid values should throw a parsing error or be replaced with <code>missing</code></li><li><code>silencewarnings::Bool=false</code>: if <code>strict=false</code>, whether invalid value warnings should be silenced</li><li><code>maxwarnings::Int=100</code>: if more than <code>maxwarnings</code> number of warnings are printed while parsing, further warnings will be silenced by default; for multithreaded parsing, each parsing task will print up to <code>maxwarnings</code></li><li><code>debug::Bool=false</code>: passing <code>true</code> will result in many informational prints while a dataset is parsed; can be useful when reporting issues or figuring out what is going on internally while a dataset is parsed</li><li><code>validate::Bool=true</code>: whether or not to validate that columns specified in the <code>types</code>, <code>dateformat</code> and <code>pool</code> keywords are actually found in the data. If <code>false</code> no validation is done, meaning no error will be thrown if <code>types</code>/<code>dateformat</code>/<code>pool</code> specify settings for columns not actually found in the data.</li></ul><p><strong>Iteration options:</strong></p><ul><li><code>reusebuffer=false</code>: [only supported by <code>CSV.Rows</code>] while iterating, whether a single row buffer should be allocated and reused on each iteration; only use if each row will be iterated once and not re-used (e.g. it&#39;s not safe to use this option if doing <code>collect(CSV.Rows(file))</code> because only current iterated row is &quot;valid&quot;)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/CSV.jl/blob/390a7d3ef15971b580d1c9ba746caae22f8db343/src/file.jl#L34-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CSV.Chunks" href="#CSV.Chunks"><code>CSV.Chunks</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CSV.Chunks(source; ntasks::Integer=Threads.nthreads(), kwargs...) =&gt; CSV.Chunks</code></pre><p>Returns a file &quot;chunk&quot; iterator. Accepts all the same inputs and keyword arguments as <a href="reading.html#CSV.File"><code>CSV.File</code></a>, see those docs for explanations of each keyword argument.</p><p>The <code>ntasks</code> keyword argument specifies how many chunks a file should be split up into, defaulting to the # of threads available to Julia (i.e. <code>JULIA_NUM_THREADS</code> environment variable) or 8 if Julia is run single-threaded.</p><p>Each iteration of <code>CSV.Chunks</code> produces the next chunk of a file as a <code>CSV.File</code>. While initial file metadata detection is done only once (to determine # of columns, column names, etc), each iteration does independent type inference on columns. This is significant as different chunks may end up with different column types than previous chunks as new values are encountered in the file. Note that, as with <code>CSV.File</code>, types may be passed manually via the <code>type</code> or <code>types</code> keyword arguments.</p><p>This functionality is new and thus considered experimental; please <a href="https://github.com/JuliaData/CSV.jl/issues/new">open an issue</a> if you run into any problems/bugs.</p><p><strong>Arguments</strong></p><p><strong>File layout options:</strong></p><ul><li><code>header=1</code>: how column names should be determined; if given as an <code>Integer</code>, indicates the row to parse for column names; as an <code>AbstractVector{&lt;:Integer}</code>, indicates a set of rows to be concatenated together as column names; <code>Vector{Symbol}</code> or <code>Vector{String}</code> give column names explicitly (should match # of columns in dataset); if a dataset doesn&#39;t have column names, either provide them as a <code>Vector</code>, or set <code>header=0</code> or <code>header=false</code> and column names will be auto-generated (<code>Column1</code>, <code>Column2</code>, etc.). Note that if a row number header and <code>comment</code> or <code>ignoreemptyrows</code> are provided, the header row will be the first non-commented/non-empty row <em>after</em> the row number, meaning if the provided row number is a commented row, the header row will actually be the next non-commented row.</li><li><code>normalizenames::Bool=false</code>: whether column names should be &quot;normalized&quot; into valid Julia identifier symbols; useful when using the <code>tbl.col1</code> <code>getproperty</code> syntax or iterating rows and accessing column values of a row via <code>getproperty</code> (e.g. <code>row.col1</code>)</li><li><code>skipto::Integer</code>: specifies the row where the data starts in the csv file; by default, the next row after the <code>header</code> row(s) is used. If <code>header=0</code>, then the 1st row is assumed to be the start of data; providing a <code>skipto</code> argument does <em>not</em> affect the <code>header</code> argument. Note that if a row number <code>skipto</code> and <code>comment</code> or <code>ignoreemptyrows</code> are provided, the data row will be the first non-commented/non-empty row <em>after</em> the row number, meaning if the provided row number is a commented row, the data row will actually be the next non-commented row.</li><li><code>footerskip::Integer</code>: number of rows at the end of a file to skip parsing.  Do note that commented rows (see the <code>comment</code> keyword argument) <em>do not</em> count towards the row number provided for <code>footerskip</code>, they are completely ignored by the parser</li><li><code>transpose::Bool</code>: read a csv file &quot;transposed&quot;, i.e. each column is parsed as a row</li><li><code>comment::String</code>: string that will cause rows that begin with it to be skipped while parsing. Note that if a row number header or <code>skipto</code> and <code>comment</code> are provided, the header/data row will be the first non-commented/non-empty row <em>after</em> the row number, meaning if the provided row number is a commented row, the header/data row will actually be the next non-commented row.</li><li><code>ignoreemptyrows::Bool=true</code>: whether empty rows in a file should be ignored (if <code>false</code>, each column will be assigned <code>missing</code> for that empty row)</li><li><code>select</code>: an <code>AbstractVector</code> of <code>Integer</code>, <code>Symbol</code>, <code>String</code>, or <code>Bool</code>, or a &quot;selector&quot; function of the form <code>(i, name) -&gt; keep::Bool</code>; only columns in the collection or for which the selector function returns <code>true</code> will be parsed and accessible in the resulting <code>CSV.File</code>. Invalid values in <code>select</code> are ignored.</li><li><code>drop</code>: inverse of <code>select</code>; an <code>AbstractVector</code> of <code>Integer</code>, <code>Symbol</code>, <code>String</code>, or <code>Bool</code>, or a &quot;drop&quot; function of the form <code>(i, name) -&gt; drop::Bool</code>; columns in the collection or for which the drop function returns <code>true</code> will ignored in the resulting <code>CSV.File</code>. Invalid values in <code>drop</code> are ignored.</li><li><code>limit</code>: an <code>Integer</code> to indicate a limited number of rows to parse in a csv file; use in combination with <code>skipto</code> to read a specific, contiguous chunk within a file; note for large files when multiple threads are used for parsing, the <code>limit</code> argument may not result in an exact # of rows parsed; use <code>threaded=false</code> to ensure an exact limit if necessary</li><li><code>buffer_in_memory</code>: a <code>Bool</code>, default <code>false</code>, which controls whether a <code>Cmd</code>, <code>IO</code>, or gzipped source will be read/decompressed in memory vs. using a temporary file.</li><li><code>ntasks::Integer=Threads.nthreads()</code>: [not applicable to <code>CSV.Rows</code>] for multithreaded parsed files, this controls the number of tasks spawned to read a file in concurrent chunks; defaults to the # of threads Julia was started with (i.e. <code>JULIA_NUM_THREADS</code> environment variable or <code>julia -t N</code>); setting <code>ntasks=1</code> will avoid any calls to <code>Threads.@spawn</code> and just read the file serially on the main thread; a single thread will also be used for smaller files by default (&lt; 5_000 cells)</li><li><code>rows_to_check::Integer=30</code>: [not applicable to <code>CSV.Rows</code>] a multithreaded parsed file will be split up into <code>ntasks</code> # of equal chunks; <code>rows_to_check</code> controls the # of rows are checked to ensure parsing correctly found valid rows; for certain files with very large quoted text fields, <code>lines_to_check</code> may need to be higher (10, 30, etc.) to ensure parsing correctly finds these rows</li><li><code>source</code>: [only applicable for vector of inputs to <code>CSV.File</code>] a <code>Symbol</code>, <code>String</code>, or <code>Pair</code> of <code>Symbol</code> or <code>String</code> to <code>Vector</code>. As a single <code>Symbol</code> or <code>String</code>, provides the column name that will be added to the parsed columns, the values of the column will be the input &quot;name&quot; (usually file name) of the input from whence the value was parsed. As a <code>Pair</code>, the 2nd part of the pair should be a <code>Vector</code> of values matching the length of the # of inputs, where each value will be used instead of the input name for that inputs values in the auto-added column.</li></ul><p><strong>Parsing options:</strong></p><ul><li><code>missingstring</code>: either a <code>nothing</code>, <code>String</code>, or <code>Vector{String}</code> to use as sentinel values that will be parsed as <code>missing</code>; if <code>nothing</code> is passed, no sentinel/missing values will be parsed; by default, <code>missingstring=&quot;&quot;</code>, which means only an empty field (two consecutive delimiters) is considered <code>missing</code></li><li><code>delim=&#39;,&#39;</code>: a <code>Char</code> or <code>String</code> that indicates how columns are delimited in a file; if no argument is provided, parsing will try to detect the most consistent delimiter on the first 10 rows of the file</li><li><code>ignorerepeated::Bool=false</code>: whether repeated (consecutive/sequential) delimiters should be ignored while parsing; useful for fixed-width files with delimiter padding between cells</li><li><code>quoted::Bool=true</code>: whether parsing should check for <code>quotechar</code> at the start/end of cells</li><li><code>quotechar=&#39;&quot;&#39;</code>, <code>openquotechar</code>, <code>closequotechar</code>: a <code>Char</code> (or different start and end characters) that indicate a quoted field which may contain textual delimiters or newline characters</li><li><code>escapechar=&#39;&quot;&#39;</code>: the <code>Char</code> used to escape quote characters in a quoted field</li><li><code>dateformat::Union{String, Dates.DateFormat, Nothing, AbstractDict}</code>: a date format string to indicate how Date/DateTime columns are formatted for the entire file; if given as an <code>AbstractDict</code>, date format strings to indicate how the Date/DateTime columns corresponding to the keys are formatted. The Dict can map column index <code>Int</code>, or name <code>Symbol</code> or <code>String</code> to the format string for that column.</li><li><code>decimal=&#39;.&#39;</code>: a <code>Char</code> indicating how decimals are separated in floats, i.e. <code>3.14</code> uses <code>&#39;.&#39;</code>, or <code>3,14</code> uses a comma <code>&#39;,&#39;</code></li><li><code>truestrings</code>, <code>falsestrings</code>: <code>Vector{String}</code>s that indicate how <code>true</code> or <code>false</code> values are represented; by default <code>&quot;true&quot;, &quot;True&quot;, &quot;TRUE&quot;, &quot;T&quot;, &quot;1&quot;</code> are used to detect <code>true</code> and <code>&quot;false&quot;, &quot;False&quot;, &quot;FALSE&quot;, &quot;F&quot;, &quot;0&quot;</code> are used to detect <code>false</code>; note that columns with only <code>1</code> and <code>0</code> values will default to <code>Int64</code> column type unless explicitly requested to be <code>Bool</code> via <code>types</code> keyword argument</li><li><code>stripwhitespace=false</code>: if true, leading and trailing whitespace are stripped from string values, including column names</li></ul><p><strong>Column Type Options:</strong></p><ul><li><code>types</code>: a single <code>Type</code>, <code>AbstractVector</code> or <code>AbstractDict</code> of types, or a function of the form <code>(i, name) -&gt; Union{T, Nothing}</code> to be used for column types; if a single <code>Type</code> is provided, <em>all</em> columns will be parsed with that single type; an <code>AbstractDict</code> can map column index <code>Integer</code>, or name <code>Symbol</code> or <code>String</code> to type for a column, i.e. <code>Dict(1=&gt;Float64)</code> will set the first column as a <code>Float64</code>, <code>Dict(:column1=&gt;Float64)</code> will set the column named <code>column1</code> to <code>Float64</code> and, <code>Dict(&quot;column1&quot;=&gt;Float64)</code> will set the <code>column1</code> to <code>Float64</code>; if a <code>Vector</code> is provided, it must match the # of columns provided or detected in <code>header</code>. If a function is provided, it takes a column index and name as arguments, and should return the desired column type for the column, or <code>nothing</code> to signal the column&#39;s type should be detected while parsing.</li><li><code>typemap::IdDict{Type, Type}</code>: a mapping of a type that should be replaced in every instance with another type, i.e. <code>Dict(Float64=&gt;String)</code> would change every detected <code>Float64</code> column to be parsed as <code>String</code>; only &quot;standard&quot; types are allowed to be mapped to another type, i.e. <code>Int64</code>, <code>Float64</code>, <code>Date</code>, <code>DateTime</code>, <code>Time</code>, and <code>Bool</code>. If a column of one of those types is &quot;detected&quot;, it will be mapped to the specified type.</li><li><code>pool::Union{Bool, Real, AbstractVector, AbstractDict, Function, Tuple{Float64, Int}}=(0.2, 500)</code>: [not supported by <code>CSV.Rows</code>] controls whether columns will be built as <code>PooledArray</code>; if <code>true</code>, all columns detected as <code>String</code> will be pooled; alternatively, the proportion of unique values below which <code>String</code> columns should be pooled (meaning that if the # of unique strings in a column is under 25%, <code>pool=0.25</code>, it will be pooled). If provided as a <code>Tuple{Float64, Int}</code> like <code>(0.2, 500)</code>, it represents the percent cardinality threshold as the 1st tuple element (<code>0.2</code>), and an upper limit for the # of unique values (<code>500</code>), under which the column will be pooled; this is the default (<code>pool=(0.2, 500)</code>). If an <code>AbstractVector</code>, each element should be <code>Bool</code>, <code>Real</code>, or <code>Tuple{Float64, Int}</code> and the # of elements should match the # of columns in the dataset; if an <code>AbstractDict</code>, a <code>Bool</code>, <code>Real</code>, or <code>Tuple{Float64, Int}</code> value can be provided for individual columns where the dict key is given as column index <code>Integer</code>, or column name as <code>Symbol</code> or <code>String</code>. If a function is provided, it should take a column index and name as 2 arguments, and return a <code>Bool</code>, <code>Real</code>, <code>Tuple{Float64, Int}</code>, or <code>nothing</code> for each column.</li><li><code>downcast::Bool=false</code>: controls whether columns detected as <code>Int64</code> will be &quot;downcast&quot; to the smallest possible integer type like <code>Int8</code>, <code>Int16</code>, <code>Int32</code>, etc.</li><li><code>stringtype=InlineStrings.InlineString</code>: controls how detected string columns will ultimately be returned; default is <code>InlineString</code>, which stores string data in a fixed-size primitive type that helps avoid excessive heap memory usage; if a column has values longer than 32 bytes, it will default to <code>String</code>. If <code>String</code> is passed, all string columns will just be normal <code>String</code> values. If <code>PosLenString</code> is passed, string columns will be returned as <code>PosLenStringVector</code>, which is a special &quot;lazy&quot; <code>AbstractVector</code> that acts as a &quot;view&quot; into the original file data. This can lead to the most efficient parsing times, but note that the &quot;view&quot; nature of <code>PosLenStringVector</code> makes it read-only, so operations like <code>push!</code>, <code>append!</code>, or <code>setindex!</code> are not supported. It also keeps a reference to the entire input dataset source, so trying to modify or delete the underlying file, for example, may fail</li><li><code>strict::Bool=false</code>: whether invalid values should throw a parsing error or be replaced with <code>missing</code></li><li><code>silencewarnings::Bool=false</code>: if <code>strict=false</code>, whether invalid value warnings should be silenced</li><li><code>maxwarnings::Int=100</code>: if more than <code>maxwarnings</code> number of warnings are printed while parsing, further warnings will be silenced by default; for multithreaded parsing, each parsing task will print up to <code>maxwarnings</code></li><li><code>debug::Bool=false</code>: passing <code>true</code> will result in many informational prints while a dataset is parsed; can be useful when reporting issues or figuring out what is going on internally while a dataset is parsed</li><li><code>validate::Bool=true</code>: whether or not to validate that columns specified in the <code>types</code>, <code>dateformat</code> and <code>pool</code> keywords are actually found in the data. If <code>false</code> no validation is done, meaning no error will be thrown if <code>types</code>/<code>dateformat</code>/<code>pool</code> specify settings for columns not actually found in the data.</li></ul><p><strong>Iteration options:</strong></p><ul><li><code>reusebuffer=false</code>: [only supported by <code>CSV.Rows</code>] while iterating, whether a single row buffer should be allocated and reused on each iteration; only use if each row will be iterated once and not re-used (e.g. it&#39;s not safe to use this option if doing <code>collect(CSV.Rows(file))</code> because only current iterated row is &quot;valid&quot;)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/CSV.jl/blob/390a7d3ef15971b580d1c9ba746caae22f8db343/src/chunks.jl#L6-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CSV.Rows" href="#CSV.Rows"><code>CSV.Rows</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CSV.Rows(source; kwargs...) =&gt; CSV.Rows</code></pre><p>Read a csv input returning a <code>CSV.Rows</code> object.</p><p>The <a href="reading.html#input"><code>input</code></a> argument can be one of:</p><ul><li>filename given as a string or FilePaths.jl type</li><li>a <code>Vector{UInt8}</code> or <code>SubArray{UInt8, 1, Vector{UInt8}}</code> byte buffer</li><li>a <code>CodeUnits</code> object, which wraps a <code>String</code>, like <code>codeunits(str)</code></li><li>a csv-formatted string can also be passed like <code>IOBuffer(str)</code></li><li>a <code>Cmd</code> or other <code>IO</code></li><li>a gzipped file (or gzipped data in any of the above), which will automatically be decompressed for parsing</li></ul><p>To read a csv file from a url, use the HTTP.jl package, where the <code>HTTP.Response</code> body can be passed like:</p><pre><code class="language-julia hljs">f = CSV.Rows(HTTP.get(url).body)</code></pre><p>For other <code>IO</code> or <code>Cmd</code> inputs, you can pass them like: <code>f = CSV.Rows(read(obj))</code>.</p><p>While similar to <a href="reading.html#CSV.File"><code>CSV.File</code></a>, <code>CSV.Rows</code> provides a slightly different interface, the tradeoffs including:</p><ul><li>Very minimal memory footprint; while iterating, only the current row values are buffered</li><li>Only provides row access via iteration; to access columns, one can stream the rows into a table type</li><li>Performs no type inference; each column/cell is essentially treated as <code>Union{String, Missing}</code>, users can utilize the performant <code>Parsers.parse(T, str)</code> to convert values to a more specific type if needed, or pass types upon construction using the <code>type</code> or <code>types</code> keyword arguments</li></ul><p>Opens the file and uses passed arguments to detect the number of columns, ***but not*** column types (column types default to <code>String</code> unless otherwise manually provided). The returned <code>CSV.Rows</code> object supports the <a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a> interface and can iterate rows. Each row object supports <code>propertynames</code>, <code>getproperty</code>, and <code>getindex</code> to access individual row values. Note that duplicate column names will be detected and adjusted to ensure uniqueness (duplicate column name <code>a</code> will become <code>a_1</code>). For example, one could iterate over a csv file with column names <code>a</code>, <code>b</code>, and <code>c</code> by doing:</p><pre><code class="language-julia hljs">for row in CSV.Rows(file)
    println(&quot;a=$(row.a), b=$(row.b), c=$(row.c)&quot;)
end</code></pre><p><strong>Arguments</strong></p><p><strong>File layout options:</strong></p><ul><li><code>header=1</code>: how column names should be determined; if given as an <code>Integer</code>, indicates the row to parse for column names; as an <code>AbstractVector{&lt;:Integer}</code>, indicates a set of rows to be concatenated together as column names; <code>Vector{Symbol}</code> or <code>Vector{String}</code> give column names explicitly (should match # of columns in dataset); if a dataset doesn&#39;t have column names, either provide them as a <code>Vector</code>, or set <code>header=0</code> or <code>header=false</code> and column names will be auto-generated (<code>Column1</code>, <code>Column2</code>, etc.). Note that if a row number header and <code>comment</code> or <code>ignoreemptyrows</code> are provided, the header row will be the first non-commented/non-empty row <em>after</em> the row number, meaning if the provided row number is a commented row, the header row will actually be the next non-commented row.</li><li><code>normalizenames::Bool=false</code>: whether column names should be &quot;normalized&quot; into valid Julia identifier symbols; useful when using the <code>tbl.col1</code> <code>getproperty</code> syntax or iterating rows and accessing column values of a row via <code>getproperty</code> (e.g. <code>row.col1</code>)</li><li><code>skipto::Integer</code>: specifies the row where the data starts in the csv file; by default, the next row after the <code>header</code> row(s) is used. If <code>header=0</code>, then the 1st row is assumed to be the start of data; providing a <code>skipto</code> argument does <em>not</em> affect the <code>header</code> argument. Note that if a row number <code>skipto</code> and <code>comment</code> or <code>ignoreemptyrows</code> are provided, the data row will be the first non-commented/non-empty row <em>after</em> the row number, meaning if the provided row number is a commented row, the data row will actually be the next non-commented row.</li><li><code>footerskip::Integer</code>: number of rows at the end of a file to skip parsing.  Do note that commented rows (see the <code>comment</code> keyword argument) <em>do not</em> count towards the row number provided for <code>footerskip</code>, they are completely ignored by the parser</li><li><code>transpose::Bool</code>: read a csv file &quot;transposed&quot;, i.e. each column is parsed as a row</li><li><code>comment::String</code>: string that will cause rows that begin with it to be skipped while parsing. Note that if a row number header or <code>skipto</code> and <code>comment</code> are provided, the header/data row will be the first non-commented/non-empty row <em>after</em> the row number, meaning if the provided row number is a commented row, the header/data row will actually be the next non-commented row.</li><li><code>ignoreemptyrows::Bool=true</code>: whether empty rows in a file should be ignored (if <code>false</code>, each column will be assigned <code>missing</code> for that empty row)</li><li><code>select</code>: an <code>AbstractVector</code> of <code>Integer</code>, <code>Symbol</code>, <code>String</code>, or <code>Bool</code>, or a &quot;selector&quot; function of the form <code>(i, name) -&gt; keep::Bool</code>; only columns in the collection or for which the selector function returns <code>true</code> will be parsed and accessible in the resulting <code>CSV.File</code>. Invalid values in <code>select</code> are ignored.</li><li><code>drop</code>: inverse of <code>select</code>; an <code>AbstractVector</code> of <code>Integer</code>, <code>Symbol</code>, <code>String</code>, or <code>Bool</code>, or a &quot;drop&quot; function of the form <code>(i, name) -&gt; drop::Bool</code>; columns in the collection or for which the drop function returns <code>true</code> will ignored in the resulting <code>CSV.File</code>. Invalid values in <code>drop</code> are ignored.</li><li><code>limit</code>: an <code>Integer</code> to indicate a limited number of rows to parse in a csv file; use in combination with <code>skipto</code> to read a specific, contiguous chunk within a file; note for large files when multiple threads are used for parsing, the <code>limit</code> argument may not result in an exact # of rows parsed; use <code>threaded=false</code> to ensure an exact limit if necessary</li><li><code>buffer_in_memory</code>: a <code>Bool</code>, default <code>false</code>, which controls whether a <code>Cmd</code>, <code>IO</code>, or gzipped source will be read/decompressed in memory vs. using a temporary file.</li><li><code>ntasks::Integer=Threads.nthreads()</code>: [not applicable to <code>CSV.Rows</code>] for multithreaded parsed files, this controls the number of tasks spawned to read a file in concurrent chunks; defaults to the # of threads Julia was started with (i.e. <code>JULIA_NUM_THREADS</code> environment variable or <code>julia -t N</code>); setting <code>ntasks=1</code> will avoid any calls to <code>Threads.@spawn</code> and just read the file serially on the main thread; a single thread will also be used for smaller files by default (&lt; 5_000 cells)</li><li><code>rows_to_check::Integer=30</code>: [not applicable to <code>CSV.Rows</code>] a multithreaded parsed file will be split up into <code>ntasks</code> # of equal chunks; <code>rows_to_check</code> controls the # of rows are checked to ensure parsing correctly found valid rows; for certain files with very large quoted text fields, <code>lines_to_check</code> may need to be higher (10, 30, etc.) to ensure parsing correctly finds these rows</li><li><code>source</code>: [only applicable for vector of inputs to <code>CSV.File</code>] a <code>Symbol</code>, <code>String</code>, or <code>Pair</code> of <code>Symbol</code> or <code>String</code> to <code>Vector</code>. As a single <code>Symbol</code> or <code>String</code>, provides the column name that will be added to the parsed columns, the values of the column will be the input &quot;name&quot; (usually file name) of the input from whence the value was parsed. As a <code>Pair</code>, the 2nd part of the pair should be a <code>Vector</code> of values matching the length of the # of inputs, where each value will be used instead of the input name for that inputs values in the auto-added column.</li></ul><p><strong>Parsing options:</strong></p><ul><li><code>missingstring</code>: either a <code>nothing</code>, <code>String</code>, or <code>Vector{String}</code> to use as sentinel values that will be parsed as <code>missing</code>; if <code>nothing</code> is passed, no sentinel/missing values will be parsed; by default, <code>missingstring=&quot;&quot;</code>, which means only an empty field (two consecutive delimiters) is considered <code>missing</code></li><li><code>delim=&#39;,&#39;</code>: a <code>Char</code> or <code>String</code> that indicates how columns are delimited in a file; if no argument is provided, parsing will try to detect the most consistent delimiter on the first 10 rows of the file</li><li><code>ignorerepeated::Bool=false</code>: whether repeated (consecutive/sequential) delimiters should be ignored while parsing; useful for fixed-width files with delimiter padding between cells</li><li><code>quoted::Bool=true</code>: whether parsing should check for <code>quotechar</code> at the start/end of cells</li><li><code>quotechar=&#39;&quot;&#39;</code>, <code>openquotechar</code>, <code>closequotechar</code>: a <code>Char</code> (or different start and end characters) that indicate a quoted field which may contain textual delimiters or newline characters</li><li><code>escapechar=&#39;&quot;&#39;</code>: the <code>Char</code> used to escape quote characters in a quoted field</li><li><code>dateformat::Union{String, Dates.DateFormat, Nothing, AbstractDict}</code>: a date format string to indicate how Date/DateTime columns are formatted for the entire file; if given as an <code>AbstractDict</code>, date format strings to indicate how the Date/DateTime columns corresponding to the keys are formatted. The Dict can map column index <code>Int</code>, or name <code>Symbol</code> or <code>String</code> to the format string for that column.</li><li><code>decimal=&#39;.&#39;</code>: a <code>Char</code> indicating how decimals are separated in floats, i.e. <code>3.14</code> uses <code>&#39;.&#39;</code>, or <code>3,14</code> uses a comma <code>&#39;,&#39;</code></li><li><code>truestrings</code>, <code>falsestrings</code>: <code>Vector{String}</code>s that indicate how <code>true</code> or <code>false</code> values are represented; by default <code>&quot;true&quot;, &quot;True&quot;, &quot;TRUE&quot;, &quot;T&quot;, &quot;1&quot;</code> are used to detect <code>true</code> and <code>&quot;false&quot;, &quot;False&quot;, &quot;FALSE&quot;, &quot;F&quot;, &quot;0&quot;</code> are used to detect <code>false</code>; note that columns with only <code>1</code> and <code>0</code> values will default to <code>Int64</code> column type unless explicitly requested to be <code>Bool</code> via <code>types</code> keyword argument</li><li><code>stripwhitespace=false</code>: if true, leading and trailing whitespace are stripped from string values, including column names</li></ul><p><strong>Column Type Options:</strong></p><ul><li><code>types</code>: a single <code>Type</code>, <code>AbstractVector</code> or <code>AbstractDict</code> of types, or a function of the form <code>(i, name) -&gt; Union{T, Nothing}</code> to be used for column types; if a single <code>Type</code> is provided, <em>all</em> columns will be parsed with that single type; an <code>AbstractDict</code> can map column index <code>Integer</code>, or name <code>Symbol</code> or <code>String</code> to type for a column, i.e. <code>Dict(1=&gt;Float64)</code> will set the first column as a <code>Float64</code>, <code>Dict(:column1=&gt;Float64)</code> will set the column named <code>column1</code> to <code>Float64</code> and, <code>Dict(&quot;column1&quot;=&gt;Float64)</code> will set the <code>column1</code> to <code>Float64</code>; if a <code>Vector</code> is provided, it must match the # of columns provided or detected in <code>header</code>. If a function is provided, it takes a column index and name as arguments, and should return the desired column type for the column, or <code>nothing</code> to signal the column&#39;s type should be detected while parsing.</li><li><code>typemap::IdDict{Type, Type}</code>: a mapping of a type that should be replaced in every instance with another type, i.e. <code>Dict(Float64=&gt;String)</code> would change every detected <code>Float64</code> column to be parsed as <code>String</code>; only &quot;standard&quot; types are allowed to be mapped to another type, i.e. <code>Int64</code>, <code>Float64</code>, <code>Date</code>, <code>DateTime</code>, <code>Time</code>, and <code>Bool</code>. If a column of one of those types is &quot;detected&quot;, it will be mapped to the specified type.</li><li><code>pool::Union{Bool, Real, AbstractVector, AbstractDict, Function, Tuple{Float64, Int}}=(0.2, 500)</code>: [not supported by <code>CSV.Rows</code>] controls whether columns will be built as <code>PooledArray</code>; if <code>true</code>, all columns detected as <code>String</code> will be pooled; alternatively, the proportion of unique values below which <code>String</code> columns should be pooled (meaning that if the # of unique strings in a column is under 25%, <code>pool=0.25</code>, it will be pooled). If provided as a <code>Tuple{Float64, Int}</code> like <code>(0.2, 500)</code>, it represents the percent cardinality threshold as the 1st tuple element (<code>0.2</code>), and an upper limit for the # of unique values (<code>500</code>), under which the column will be pooled; this is the default (<code>pool=(0.2, 500)</code>). If an <code>AbstractVector</code>, each element should be <code>Bool</code>, <code>Real</code>, or <code>Tuple{Float64, Int}</code> and the # of elements should match the # of columns in the dataset; if an <code>AbstractDict</code>, a <code>Bool</code>, <code>Real</code>, or <code>Tuple{Float64, Int}</code> value can be provided for individual columns where the dict key is given as column index <code>Integer</code>, or column name as <code>Symbol</code> or <code>String</code>. If a function is provided, it should take a column index and name as 2 arguments, and return a <code>Bool</code>, <code>Real</code>, <code>Tuple{Float64, Int}</code>, or <code>nothing</code> for each column.</li><li><code>downcast::Bool=false</code>: controls whether columns detected as <code>Int64</code> will be &quot;downcast&quot; to the smallest possible integer type like <code>Int8</code>, <code>Int16</code>, <code>Int32</code>, etc.</li><li><code>stringtype=InlineStrings.InlineString</code>: controls how detected string columns will ultimately be returned; default is <code>InlineString</code>, which stores string data in a fixed-size primitive type that helps avoid excessive heap memory usage; if a column has values longer than 32 bytes, it will default to <code>String</code>. If <code>String</code> is passed, all string columns will just be normal <code>String</code> values. If <code>PosLenString</code> is passed, string columns will be returned as <code>PosLenStringVector</code>, which is a special &quot;lazy&quot; <code>AbstractVector</code> that acts as a &quot;view&quot; into the original file data. This can lead to the most efficient parsing times, but note that the &quot;view&quot; nature of <code>PosLenStringVector</code> makes it read-only, so operations like <code>push!</code>, <code>append!</code>, or <code>setindex!</code> are not supported. It also keeps a reference to the entire input dataset source, so trying to modify or delete the underlying file, for example, may fail</li><li><code>strict::Bool=false</code>: whether invalid values should throw a parsing error or be replaced with <code>missing</code></li><li><code>silencewarnings::Bool=false</code>: if <code>strict=false</code>, whether invalid value warnings should be silenced</li><li><code>maxwarnings::Int=100</code>: if more than <code>maxwarnings</code> number of warnings are printed while parsing, further warnings will be silenced by default; for multithreaded parsing, each parsing task will print up to <code>maxwarnings</code></li><li><code>debug::Bool=false</code>: passing <code>true</code> will result in many informational prints while a dataset is parsed; can be useful when reporting issues or figuring out what is going on internally while a dataset is parsed</li><li><code>validate::Bool=true</code>: whether or not to validate that columns specified in the <code>types</code>, <code>dateformat</code> and <code>pool</code> keywords are actually found in the data. If <code>false</code> no validation is done, meaning no error will be thrown if <code>types</code>/<code>dateformat</code>/<code>pool</code> specify settings for columns not actually found in the data.</li></ul><p><strong>Iteration options:</strong></p><ul><li><code>reusebuffer=false</code>: [only supported by <code>CSV.Rows</code>] while iterating, whether a single row buffer should be allocated and reused on each iteration; only use if each row will be iterated once and not re-used (e.g. it&#39;s not safe to use this option if doing <code>collect(CSV.Rows(file))</code> because only current iterated row is &quot;valid&quot;)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/CSV.jl/blob/390a7d3ef15971b580d1c9ba746caae22f8db343/src/rows.jl#L35-L74">source</a></section></article><h3 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CSV.detect" href="#CSV.detect"><code>CSV.detect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">CSV.detect(str::String)</code></pre><p>Use the same logic used by <code>CSV.File</code> to detect column types, to parse a value from a plain string. This can be useful in conjunction with the <code>CSV.Rows</code> type, which returns each cell of a file as a String. The order of types attempted is: <code>Int</code>, <code>Float64</code>, <code>Date</code>, <code>DateTime</code>, <code>Bool</code>, and if all fail, the input String is returned. No errors are thrown. For advanced usage, you can pass your own <code>Parsers.Options</code> type as a keyword argument <code>option=ops</code> for sentinel value detection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/CSV.jl/blob/390a7d3ef15971b580d1c9ba746caae22f8db343/src/utils.jl#L431-L439">source</a></section></article><h2 id="Common-terms"><a class="docs-heading-anchor" href="#Common-terms">Common terms</a><a id="Common-terms-1"></a><a class="docs-heading-anchor-permalink" href="#Common-terms" title="Permalink"></a></h2><h3 id="Standard-types"><a class="docs-heading-anchor" href="#Standard-types">Standard types</a><a id="Standard-types-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-types" title="Permalink"></a></h3><p>The types that are detected by default when column types are not provided by the user otherwise. They include: <code>Int64</code>, <code>Float64</code>, <code>Date</code>, <code>DateTime</code>, <code>Time</code>, <code>Bool</code>, and <code>String</code>.</p><h3 id="newlines"><a class="docs-heading-anchor" href="#newlines">Newlines</a><a id="newlines-1"></a><a class="docs-heading-anchor-permalink" href="#newlines" title="Permalink"></a></h3><p>For all parsing functionality, newlines are detected/parsed automatically, regardless if they&#39;re present in the data as a single newline character (<code>&#39;\n&#39;</code>), single return character (&#39;<code>\r&#39;</code>), or full CRLF sequence (<code>&quot;\r\n&quot;</code>).</p><h3 id="Cardinality"><a class="docs-heading-anchor" href="#Cardinality">Cardinality</a><a id="Cardinality-1"></a><a class="docs-heading-anchor-permalink" href="#Cardinality" title="Permalink"></a></h3><p>Refers to the ratio of unique values to total number of values in a column. Columns with &quot;low cardinality&quot; have a low % of unique values, or put another way, there are only a few unique values for the entire column of data where unique values are repeated many times. Columns with &quot;high cardinality&quot; have a high % of unique values relative to total number of values. Think of these as &quot;id-like&quot; columns where each or almost each value is a unique identifier with no (or few) repeated values.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Home</a><a class="docs-footer-nextpage" href="writing.html">Writing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 9 May 2023 14:28">Tuesday 9 May 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
